{"jsonrpc":"2.0","id":1,"result":{"content":[{"type":"text","text":"{\n  \"file_path\": \"/usr/sbin/adduser\",\n  \"metadata\": {\n    \"file_path\": \"/usr/sbin/adduser\",\n    \"file_name\": \"adduser\",\n    \"file_size\": 48382,\n    \"created\": \"2025-05-30T23:42:20.226730098Z\",\n    \"modified\": \"2023-05-25T15:54:35Z\",\n    \"accessed\": \"2023-05-25T15:54:35Z\",\n    \"permissions\": \"755\",\n    \"is_executable\": true,\n    \"mime_type\": \"application/octet-stream\",\n    \"hashes\": {\n      \"md5\": \"2ba08fece3b3434a669f3c529bbea383\",\n      \"sha256\": \"ad8ec15dc661b2ccb236584721c8395a0dd910151d486b0c1440b715ba1beb70\",\n      \"sha512\": \"1071cc742b90e14918b76ab656f04108b8a303bf634d24e36ad3025a21fabc20024ecd3f06366fa0f82b9c7152f158f08673f6c9a58f269fc887ede4720d2877\",\n      \"blake3\": \"ace02be071fbed947363237c6706a67e364c4a1a93f8be7050cde8344a69f0c7\"\n    },\n    \"binary_info\": null,\n    \"extracted_strings\": null,\n    \"signature_info\": null,\n    \"hex_dump\": null,\n    \"owner_uid\": 0,\n    \"group_gid\": 0\n  },\n  \"hashes\": {\n    \"md5\": \"2ba08fece3b3434a669f3c529bbea383\",\n    \"sha256\": \"ad8ec15dc661b2ccb236584721c8395a0dd910151d486b0c1440b715ba1beb70\",\n    \"sha512\": \"1071cc742b90e14918b76ab656f04108b8a303bf634d24e36ad3025a21fabc20024ecd3f06366fa0f82b9c7152f158f08673f6c9a58f269fc887ede4720d2877\",\n    \"blake3\": \"ace02be071fbed947363237c6706a67e364c4a1a93f8be7050cde8344a69f0c7\"\n  },\n  \"strings\": [\n    \"#! /usr/bin/perl\",\n    \"# Copyright (C) 1997-1999 Guy Maor <maor@debian.org>\",\n    \"# Copyright (C) 1995 Ted Hajek <tedhajek@boombox.micro.umn.edu>\",\n    \"#                    Ian A. Murdock <imurdock@gnu.ai.mit.edu>\",\n    \"# Thanks to Roland Bauerschmidt <rb@debian.org> for bugfixes and other\",\n    \"# improvements.\",\n    \"# The general scheme of this program was adapted from the original\",\n    \"# Debian \\\"adduser\\\" program by Ian A. Murdock <imurdock@gnu.ai.mit.edu>.\",\n    \"# This program is free software; you can redistribute it and/or modify\",\n    \"# it under the terms of the GNU General Public License as published by\",\n    \"# the Free Software Foundation; either version 2 of the License, or (at\",\n    \"# your option) any later version.\",\n    \"# This program is distributed in the hope that it will be useful, but\",\n    \"# WITHOUT ANY WARRANTY; without even the implied warranty of\",\n    \"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\",\n    \"# General Public License for more details.\",\n    \"# You should have received a copy of the GNU General Public License\",\n    \"# along with this program; if not, write to:\",\n    \"#   Free Software Foundation\",\n    \"#   51 Franklin Street, Fifth Floor\",\n    \"#   Boston, MA 02110\",\n    \"#   USA\",\n    \"use strict;\",\n    \"use warnings;\",\n    \"use Getopt::Long;\",\n    \"use Debian::AdduserCommon;\",\n    \"use constant RET_OK => 0; # OK\",\n    \"use constant RET_OBJECT_ALREADY_EXISTS => 1; # the user or group does already exist, so the requested action cannot be performed\",\n    \"use constant RET_INVALID_CHARS_IN_NAME => 1; # the provided name contains invalid characters\",\n    \"use constant RET_ADDUSER_ABORTED => 1;  # the program was aborted (eg via Ctrl+C)\",\n    \"use constant RET_INVALID_CALL => 1; # getopt returned with \\\"false\\\"\",\n    \"my $version = \\\"3.134\\\";\",\n    \"BEGIN {\",\n    \"    local $ENV{PERL_DL_NONLAZY}=1;\",\n    \"    eval 'use Locale::gettext';\",\n    \"    if ($@) {\",\n    \"        *gettext = sub { shift };\",\n    \"        *textdomain = sub { \\\"\\\" };\",\n    \"        *LC_MESSAGES = sub { 5 };\",\n    \"    }\",\n    \"    eval {\",\n    \"        require POSIX;\",\n    \"        import POSIX qw(setlocale);\",\n    \"    };\",\n    \"    if ($@) {\",\n    \"        *setlocale = sub { return 1 };\",\n    \"    }\",\n    \"    eval {\",\n    \"        require I18N::Langinfo;\",\n    \"        import I18N::Langinfo qw(langinfo YESEXPR NOEXPR);\",\n    \"    };\",\n    \"    if ($@) {\",\n    \"        *langinfo = sub { return shift; };\",\n    \"        *YESEXPR  = sub { \\\"^[yY]\\\" };\",\n    \"        *NOEXPR   = sub { \\\"^[nN]\\\" };\",\n    \"    }\",\n    \"setlocale(LC_MESSAGES, \\\"\\\");\",\n    \"textdomain(\\\"adduser\\\");\",\n    \"my $yesexpr = langinfo(YESEXPR());\",\n    \"my %config;\",\n    \"# configuration hash\",\n    \"my $nogroup_id = getgrnam(\\\"nogroup\\\") || 65534;\",\n    \"$0 =~ s+.*/++;\",\n    \"our $verbose = 1;\",\n    \"# should we be verbose?\",\n    \"my $name_check_level = 0;\",\n    \"# should we allow bad names?\",\n    \"my $ask_passwd = 1;\",\n    \"# ask for a passwd?\",\n    \"my $disabled_login = 0;\",\n    \"# leave the new account disabled?\",\n    \"our @configfiles;\",\n    \"our @defaults = undef;\",\n    \"our $found_group_opt = undef;\",\n    \"our $found_sys_opt = undef;\",\n    \"our $ingroup_name = undef;\",\n    \"our $new_firstgid = undef;\",\n    \"our $new_firstuid = undef;\",\n    \"our $new_comment = undef;\",\n    \"our $gid_option = undef;\",\n    \"our $primary_gid = undef;\",\n    \"our $new_lastgid = undef;\",\n    \"our $new_lastuid = undef;\",\n    \"our $new_uid = undef;\",\n    \"our $no_create_home = undef;\",\n    \"our $special_home = undef;\",\n    \"our $special_shell = undef;\",\n    \"our $add_extra_groups;\",\n    \"our $add_extra_groups_old;\",\n    \"# Global variables we need later\",\n    \"my $existing_user = undef;\",\n    \"my $existing_group = undef;\",\n    \"my $new_name = undef;\",\n    \"my $make_group_also = 0;\",\n    \"my $home_dir = undef;\",\n    \"my $undohome = undef;\",\n    \"my $undouser = undef;\",\n    \"my $undogroup = undef;\",\n    \"my $shell = undef;\",\n    \"my $first_uid = undef;\",\n    \"my $last_uid = undef;\",\n    \"my $first_gid = undef;\",\n    \"my $last_gid = undef;\",\n    \"my $dir_mode = undef;\",\n    \"my $perm = undef;\",\n    \"my %uid_pool;\",\n    \"my %gid_pool;\",\n    \"our @names;\",\n    \"GetOptions(\",\n    \"    'add-extra-groups' => \\\\$add_extra_groups,\",\n    \"    'add_extra_groups' => \\\\$add_extra_groups_old,\",\n    \"    'allow-all-names' => sub { $name_check_level = 2 },\",\n    \"    'allow-badname' => sub { $name_check_level = 1 unless $name_check_level },\",\n    \"    'allow-bad-names' => sub { $name_check_level = 1 unless $name_check_level },\",\n    \"    'comment=s' => \\\\$new_comment,\",\n    \"    'conf|c=s' => \\\\@configfiles,\",\n    \"    'debug' => sub { $verbose = 2 },\",\n    \"    'disabled-login' => sub { $disabled_login = 1; $ask_passwd = 0 },\",\n    \"    'disabled-password' => sub { $ask_passwd = 0 },\",\n    \"    'firstgid=i' => \\\\$new_firstgid,\",\n    \"    'firstuid=i' => \\\\$new_firstuid,\",\n    \"    'force-badname' => sub { $name_check_level = 1 unless $name_check_level },\",\n    \"    'gecos=s' => \\\\$new_comment,\",\n    \"    'gid=i' => \\\\$gid_option,\",\n    \"    'group' => \\\\$found_group_opt,\",\n    \"    'help|h' => sub { &usage; exit },\",\n    \"    'home=s' => \\\\$special_home,\",\n    \"    'ingroup=s' => \\\\$ingroup_name,\",\n    \"    'lastgid=i' => \\\\$new_lastgid,\",\n    \"    'lastuid=i' => \\\\$new_lastuid,\",\n    \"    'no-create-home' => \\\\$no_create_home,\",\n    \"    'quiet|q' => sub { $verbose = 0 },\",\n    \"    'shell=s' => \\\\$special_shell,\",\n    \"    'system' => \\\\$found_sys_opt,\",\n    \"    'uid=i' => \\\\$new_uid,\",\n    \"    'verbose' => sub { $verbose = 1 },\",\n    \"    'version|v' => sub { &version; exit },\",\n    \") or &usage_error;\",\n    \"# everyone can issue \\\"--help\\\" and \\\"--version\\\", but only root can go on\",\n    \"dief (gtx(\\\"Only root may add a user or group to the system.\\\\n\\\")) if ($> != 0);\",\n    \"if(!@configfiles) {\",\n    \"    @defaults = (\\\"/etc/adduser.conf\\\");\",\n    \"} else {\",\n    \"    @defaults = (@configfiles);\",\n    \"# detect the right mode\",\n    \"my $action = $0 eq \\\"addgroup\\\" ? \\\"addgroup\\\" : \\\"adduser\\\";\",\n    \"if (defined($found_sys_opt)) {\",\n    \"  $action = \\\"addsysuser\\\" if ($action eq \\\"adduser\\\");\",\n    \"  $action = \\\"addsysgroup\\\" if ($action eq \\\"addgroup\\\");\",\n    \"# explicitly set PATH, because super (1) cleans up the path and makes adduser unusable;\",\n    \"# this is also a good idea for sudo (which doesn't clean up)\",\n    \"$ENV{\\\"PATH\\\"}=\\\"/bin:/usr/bin:/sbin:/usr/sbin\\\";\",\n    \"$ENV{\\\"IFS\\\"}=\\\" \\\\t\\\\n\\\";\",\n    \"############################\",\n    \"# checks related to @names #\",\n    \"############################\",\n    \"while (defined(my $arg = shift(@ARGV))) {\",\n    \"  push (@names, $arg);\",\n    \"if ( (! defined $names[0]) || length($names[0]) == 0 || @names > 2) {\",\n    \"    dief (gtx(\\\"Only one or two names allowed.\\\\n\\\"));\",\n    \"if (@names == 2) {\",\n    \"# must be addusertogroup\",\n    \"    if ($action eq \\\"addsysuser\\\" || $found_group_opt) {\",\n    \"        dief (gtx(\\\"Specify only one name in this mode.\\\\n\\\"))\",\n    \"    }\",\n    \"    if ($action eq \\\"addgroup\\\" or $action eq \\\"addsysgroup\\\") {\",\n    \"        dief (gtx(\\\"addgroup with two arguments is an unspecified operation.\\\\n\\\"));\",\n    \"    }\",\n    \"    $action = \\\"addusertogroup\\\";\",\n    \"    $existing_user = shift (@names);\",\n    \"    $existing_group = shift (@names);\",\n    \"else { # 1 parameter, must be adduser\",\n    \"    $new_name = shift (@names);\",\n    \"###################################\",\n    \"# check for consistent parameters #\",\n    \"###################################\",\n    \"if (!defined $add_extra_groups) {\",\n    \"    if( defined $add_extra_groups_old ) {\",\n    \"        $add_extra_groups = $add_extra_groups_old;\",\n    \"    } else {\",\n    \"        $add_extra_groups = 0;\",\n    \"    }\",\n    \"if ($action ne \\\"addgroup\\\" &&\",\n    \"    defined($found_group_opt) +defined($ingroup_name) +defined($gid_option) > 1 ) {\",\n    \"    dief (gtx(\\\"The --group, --ingroup, and --gid options are mutually exclusive.\\\\n\\\"));\",\n    \"if ((defined($special_home)) && ($special_home !~ m+^/+ )) {\",\n    \"  dief (gtx(\\\"The home dir must be an absolute path.\\\\n\\\"));\",\n    \"if (defined($special_home) && $verbose) {\",\n    \"    warnf gtx(\\\"Warning: The home dir %s you specified already exists.\\\\n\\\"),$special_home\",\n    \"      if (!defined($no_create_home) && -d $special_home);\",\n    \"    warnf gtx(\\\"Warning: The home dir %s you specified can't be accessed: %s\\\\n\\\"), $special_home, $!\",\n    \"      if (defined($no_create_home) && ! -d $special_home);\",\n    \"if ($found_group_opt) {\",\n    \"    if ($action eq \\\"addsysuser\\\") {\",\n    \"        $make_group_also = 1;\",\n    \"    }\",\n    \"    elsif ($found_sys_opt) {\",\n    \"        $action = \\\"addsysgroup\\\";\",\n    \"    }\",\n    \"    else {\",\n    \"        $action = \\\"addgroup\\\";\",\n    \"    }\",\n    \"$ENV{\\\"VERBOSE\\\"} = $verbose;\",\n    \"$ENV{\\\"DEBUG\\\"}   = $verbose;\",\n    \"# preseed configuration data and then read the config file\",\n    \"preseed_config(\\\\@defaults,\\\\%config);\",\n    \"# read the uid and gid pool\",\n    \"if ($config{\\\"uid_pool\\\"}) {\",\n    \"    read_pool ($config{\\\"uid_pool\\\"}, \\\"uid\\\", \\\\%uid_pool);\",\n    \"if ($config{\\\"gid_pool\\\"}) {\",\n    \"    read_pool ($config{\\\"gid_pool\\\"}, \\\"gid\\\", \\\\%gid_pool);\",\n    \"&checkname($new_name) if defined $new_name;\",\n    \"$SIG{'INT'} = $SIG{'QUIT'} = $SIG{'HUP'} = 'handler';\",\n    \"#####\",\n    \"# OK, we've processed the arguments.  $action equals one of the following,\",\n    \"# and the appropriate variables have been set:\",\n    \"# $action = \\\"adduser\\\"\",\n    \"#    $new_name                - the name of the new user.\",\n    \"#    $ingroup_name | $gid_option - the group to add the user to\",\n    \"#    $special_home, $new_uid, $new_comment - optional overrides\",\n    \"# $action = \\\"addgroup\\\"\",\n    \"#    $new_name                - the name of the new group\",\n    \"#    $gid_option                 - optional override\",\n    \"# $action = \\\"addsysgroup\\\"\",\n    \"#    $new_name                - the name of the new group\",\n    \"#    $gid_option                 - optional override\",\n    \"# $action = \\\"addsysuser\\\"\",\n    \"#    $new_name                - the name of the new user\",\n    \"#    $make_group_also | $ingroup_name | $gid_option | 0  - which group\",\n    \"#    $special_home, $new_uid, $new_comment - optional overrides\",\n    \"# $action = \\\"addusertogroup\\\"\",\n    \"#    $existing_user           - the user to be added\",\n    \"#    $existing_group          - the group to add her to\",\n    \"#####\",\n    \"#################\",\n    \"## addsysgroup ##\",\n    \"#################\",\n    \"if ($action eq \\\"addsysgroup\\\") {\",\n    \"    acquire_lock();\",\n    \"    # Check if requested group already exists and we can exit safely\",\n    \"    my $ret = existing_group_ok($new_name, $gid_option);\",\n    \"    if ($ret == 3) {\",\n    \"        warnf (gtx(\\\"The group `%s' already exists as a system group. Exiting.\\\\n\\\"), $new_name) if $verbose;\",\n    \"        exit RET_OK;\",\n    \"    }\",\n    \"    if ($ret == 1) {\",\n    \"        warnf (gtx(\\\"The group `%s' already exists and is not a system group. Exiting.\\\\n\\\"), $new_name);\",\n    \"        exit RET_OBJECT_ALREADY_EXISTS;\",\n    \"    }\",\n    \"    if ($ret == 2) {\",\n    \"        warnf (gtx(\\\"The group `%s' already exists, but has a different GID. Exiting.\\\\n\\\"), $new_name);\",\n    \"        exit RET_OBJECT_ALREADY_EXISTS;\",\n    \"    }\",\n    \"    if (defined($gid_option) && defined(getgrgid($gid_option))) {\",\n    \"        dief (gtx(\\\"The GID `%s' is already in use.\\\\n\\\"),$gid_option);\",\n    \"    }\",\n    \"    if (!defined($gid_option)) {\",\n    \"        $first_gid = $new_firstgid || $config{\\\"first_system_gid\\\"};\",\n    \"        $last_gid = $new_lastgid || $config{\\\"last_system_gid\\\"};\",\n    \"        $gid_option = &first_avail_gid($first_gid,\",\n    \"                           $last_gid,\",\n    \"                           $gid_pool{$new_name}{'id'});\",\n    \"        if ($gid_option == -1) {\",\n    \"            warnf gtx(\\\"No GID is available in the range %d-%d (FIRST_SYS_GID - LAST_SYS_GID).\\\\n\\\"),$first_gid,$last_gid;\",\n    \"            dief (gtx(\\\"The group `%s' was not created.\\\\n\\\"),$new_name);\",\n    \"        }\",\n    \"    }\",\n    \"    printf (gtx(\\\"Adding group `%s' (GID %d) ...\\\\n\\\"),$new_name,$gid_option) if $verbose;\",\n    \"    my $groupadd = &which('groupadd');\",\n    \"    &systemcall($groupadd, '-g', $gid_option, $new_name);\",\n    \"    release_lock(0);\",\n    \"    print (gtx(\\\"Done.\\\\n\\\")) if $verbose;\",\n    \"    exit RET_OK;\",\n    \"##############\",\n    \"## addgroup ##\",\n    \"##############\",\n    \"if ($action eq \\\"addgroup\\\") {\",\n    \"    acquire_lock();\",\n    \"    if (defined getgrnam($new_name)) {\",\n    \"        dief (gtx(\\\"The group `%s' already exists.\\\\n\\\"),$new_name);\",\n    \"    }\",\n    \"    if (defined($gid_option) && defined(getgrgid($gid_option))) {\",\n    \"        dief (gtx(\\\"The GID `%s' is already in use.\\\\n\\\"),$gid_option)\",\n    \"    }\",\n    \"    if (!defined($gid_option)) {\",\n    \"        $first_gid = $new_firstgid || $config{\\\"first_gid\\\"};\",\n    \"        $last_gid = $new_lastgid || $config{\\\"last_gid\\\"};\",\n    \"        debugf( \\\"Searching for gid with first_gid=%s, last_gid=%s, new_name=%s, gid_pool=%s\\\",\",\n    \"                $first_gid,\",\n    \"                $last_gid,\",\n    \"                $new_name,\",\n    \"                $gid_pool{$new_name}{'id'}\",\n    \"            );\",\n    \"        $gid_option = &first_avail_gid($first_gid,\",\n    \"                           $last_gid,\",\n    \"                           $gid_pool{$new_name}{'id'});\",\n    \"        if ($gid_option == -1) {\",\n    \"            print STDERR \\\"$0: \\\";\",\n    \"            printf STDERR gtx(\\\"No GID is available in the range %d-%d (FIRST_GID - LAST_GID).\\\\n\\\"),$first_gid,$last_gid;\",\n    \"            dief (gtx(\\\"The group `%s' was not created.\\\\n\\\"),$new_name);\",\n    \"        }\",\n    \"    }\",\n    \"    printf (gtx(\\\"Adding group `%s' (GID %d) ...\\\\n\\\"),$new_name,$gid_option) if $verbose;\",\n    \"    my $groupadd = &which('groupadd');\",\n    \"    &systemcall($groupadd, '-g', $gid_option, $new_name);\",\n    \"    release_lock(0);\",\n    \"    print (gtx(\\\"Done.\\\\n\\\")) if $verbose;\",\n    \"    exit RET_OK;\",\n    \"####################\",\n    \"## addusertogroup ##\",\n    \"####################\",\n    \"if ($action eq 'addusertogroup') {\",\n    \"    dief(gtx(\\\"The user `%s' does not exist.\\\\n\\\"), $existing_user) if (!defined getpwnam($existing_user));\",\n    \"    dief(gtx(\\\"The group `%s' does not exist.\\\\n\\\"), $existing_group) if (!defined getgrnam($existing_group));\",\n    \"    if (&user_is_member($existing_user, $existing_group)) {\",\n    \"        warnf gtx(\\\"The user `%s' is already a member of `%s'.\\\\n\\\"), $existing_user, $existing_group if $verbose;\",\n    \"        exit RET_OK;\",\n    \"    }\",\n    \"    printf gtx(\\\"Adding user `%s' to group `%s' ...\\\\n\\\"), $existing_user, $existing_group if $verbose;\",\n    \"    acquire_lock();\",\n    \"    &systemcall('/usr/sbin/usermod', '-a', '-G', $existing_group, $existing_user);\",\n    \"    release_lock();\",\n    \"    print gtx(\\\"Done.\\\\n\\\") if $verbose;\",\n    \"    exit RET_OK;\",\n    \"################\",\n    \"## addsysuser ##\",\n    \"################\",\n    \"if ($action eq \\\"addsysuser\\\") {\",\n    \"    acquire_lock();\",\n    \"    if (existing_user_ok($new_name, $new_uid) == 1) {\",\n    \"        # a user with this name already exists; it's a problem when it's not a system user\",\n    \"        my $tmp_u = getpwnam($new_name);\",\n    \"        if (($tmp_u >= $config{\\\"first_system_uid\\\"}) and ($tmp_u <= $config{\\\"last_system_uid\\\"})) {\",\n    \"            printf (gtx(\\\"The system user `%s' already exists. Exiting.\\\\n\\\"), $new_name) if $verbose;\",\n    \"            exit RET_OK\",\n    \"        }\",\n    \"        warnf (gtx(\\\"The user `%s' already exists, but is not a system user. Exiting.\\\\n\\\"), $new_name);\",\n    \"        exit RET_OBJECT_ALREADY_EXISTS;\",\n    \"    }\",\n    \"    if (existing_user_ok($new_name, $new_uid) == 2) {\",\n    \"        warnf (gtx(\\\"The user `%s' already exists with a different UID. Exiting.\\\\n\\\"), $new_name);\",\n    \"        exit RET_OBJECT_ALREADY_EXISTS;\",\n    \"    }\",\n    \"    if (!$ingroup_name && !defined($gid_option) && !$make_group_also) {\",\n    \"      $gid_option = $nogroup_id;\",\n    \"    }\",\n    \"    check_user_group(1);\",\n    \"    if (!defined($new_uid) && $make_group_also) {\",\n    \"        $new_uid = &first_avail_uid($new_firstuid || $config{\\\"first_system_uid\\\"},\",\n    \"                                    $new_lastuid || $config{\\\"last_system_uid\\\"},\",\n    \"                                    $uid_pool{$new_name}{'id'});\",\n    \"        if ($new_uid == -1) {\",\n    \"            warnf gtx(\\\"No UID/GID pair is available in the range %d-%d (FIRST_SYS_UID - LAST_SYS_UID).\\\\n\\\"),$config{\\\"first_system_uid\\\"},$config{\\\"last_system_uid\\\"};\",\n    \"            dief (gtx(\\\"The user `%s' was not created.\\\\n\\\"),$new_name);\",\n    \"        }\",\n    \"        $gid_option = &first_avail_gid($new_firstgid || $config{\\\"first_system_gid\\\"},\",\n    \"                                       $new_lastgid || $config{\\\"last_system_gid\\\"},\",\n    \"                                       $gid_pool{$new_name}{'id'});\",\n    \"        $ingroup_name = $new_name;\",\n    \"    }\",\n    \"    elsif (!defined($new_uid) && !$make_group_also) {\",\n    \"        $new_uid = &first_avail_uid($new_firstuid || $config{\\\"first_system_uid\\\"},\",\n    \"                                    $new_lastuid || $config{\\\"last_system_uid\\\"},\",\n    \"                                    $uid_pool{$new_name}{'id'});\",\n    \"        if ($new_uid == -1) {\",\n    \"            warnf gtx(\\\"No UID is available in the range %d-%d (FIRST_SYS_UID - LAST_SYS_UID).\\\\n\\\"),$config{\\\"first_system_uid\\\"},$config{\\\"last_system_uid\\\"};\",\n    \"            dief (gtx(\\\"The user `%s' was not created.\\\\n\\\"),$new_name);\",\n    \"        }\",\n    \"        if (defined($gid_option)) { $ingroup_name = getgrgid($gid_option); }\",\n    \"        elsif ($ingroup_name) { $gid_option = getgrnam($ingroup_name); }\",\n    \"        else { dief (gtx(\\\"Internal error\\\\n\\\")); }\",\n    \"    }\",\n    \"    else {\",\n    \"        if (defined($gid_option)) { $ingroup_name = getgrgid($gid_option); }\",\n    \"        elsif ($ingroup_name) { $gid_option = getgrnam($ingroup_name); }\",\n    \"        elsif ($make_group_also){ $gid_option=$new_uid; $ingroup_name=$new_name; }\",\n    \"        else { dief (gtx(\\\"Internal error\\\\n\\\")); }\",\n    \"    }\",\n    \"    printf (gtx(\\\"Adding system user `%s' (UID %d) ...\\\\n\\\"),$new_name,$new_uid) if $verbose;\",\n    \"    # if we reach this point, and the group does already exist, we can use it.\",\n    \"    if ($make_group_also && !getgrnam($new_name)) {\",\n    \"        printf (gtx(\\\"Adding new group `%s' (GID %d) ...\\\\n\\\"),$new_name,$gid_option) if $verbose;\",\n    \"        $undogroup = $new_name;\",\n    \"        my $groupadd = &which('groupadd');\",\n    \"        &systemcall($groupadd, '-g', $gid_option, $new_name);\",\n    \"    }\",\n    \"    printf gtx(\\\"Adding new user `%s' (UID %d) with group `%s' ...\\\\n\\\"),$new_name,$new_uid,$ingroup_name\",\n    \"        if $verbose;\",\n    \"    $home_dir = $special_home || $uid_pool{$new_name}{'home'} || '/nonexistent';\",\n    \"    $no_create_home = $home_dir =~ /^\\\\/+nonexistent(\\\\/|$)/ ? 1 : $no_create_home;\",\n    \"    $shell = $special_shell || $uid_pool{$new_name}{'shell'} || '/usr/sbin/nologin';\",\n    \"    $undouser = $new_name;\",\n    \"    &systemcall('/usr/sbin/useradd', '-r',\",\n    \"        '-K', sprintf('SYS_UID_MIN=%d', $new_firstuid || $config{'first_system_uid'}),\",\n    \"        '-K', sprintf('SYS_UID_MAX=%d', $new_lastuid || $config{'last_system_uid'}),\",\n    \"        '-d', $home_dir,\",\n    \"        '-g', $ingroup_name,\",\n    \"        '-s', $shell,\",\n    \"        '-u', $new_uid,\",\n    \"        $new_name);\",\n    \"    release_lock(0);\",\n    \"    if (defined($new_comment)) {\",\n    \"        &ch_comment($new_comment);\",\n    \"    } elsif ($uid_pool{$new_name}{'comment'}) {\",\n    \"        &ch_comment($uid_pool{$new_name}{'comment'});\",\n    \"    }\",\n    \"    $primary_gid = $gid_option;\",\n    \"    create_homedir(0);\",\n    \"    exit RET_OK;\",\n    \"#############\",\n    \"## adduser ##\",\n    \"#############\",\n    \"if ($action eq \\\"adduser\\\") {\",\n    \"    acquire_lock();\",\n    \"    $primary_gid=-1;\",\n    \"    my @supplemental_groups=();\",\n    \"    debugf( \\\"new_uid %s\\\\n\\\", $new_uid );\",\n    \"    debugf( \\\"ingroup_name %s, gid_option %s\\\\n\\\", $ingroup_name, $gid_option );\",\n    \"    debugf( \\\"usergroups %s\\\\n\\\", $config{\\\"usergroups\\\"} );\",\n    \"    debugf( \\\"users_gid %s, users_group %s\\\\n\\\", $config{\\\"users_gid\\\"}, $config{\\\"users_group\\\"} );\",\n    \"    debugf( \\\"primary_gid %s, supplemental groups %s\\\\n\\\", $primary_gid, join(\\\", \\\",@supplemental_groups) );\",\n    \"    if( defined($config{\\\"users_gid\\\"}) && defined($config{\\\"users_group\\\"}) ) {\",\n    \"        warnf gtx(\\\"USERS_GID and USERS_GROUP both given in configuration. This is an error.\\\\n\\\");\",\n    \"        dief (gtx(\\\"The user `%s' was not created.\\\\n\\\"),$new_name);\",\n    \"    }\",\n    \"    if ($config{\\\"usergroups\\\"} =~  /yes/i) {\",\n    \"        debugf( \\\"config usergroups == yes code path\\\\n\\\" );\",\n    \"        $make_group_also = 1;\",\n    \"        if( $gid_option ) {\",\n    \"            $make_group_also = 0;\",\n    \"            $primary_gid = $gid_option;\",\n    \"            debugf( \\\"gid_option defined %s, make_group_also 0, primary_gid=gid_option\\\\n\\\", $gid_option );\",\n    \"        }\",\n    \"        if( $ingroup_name ) {\",\n    \"            $make_group_also = 0;\",\n    \"            $primary_gid = getgrnam($ingroup_name);\",\n    \"            debugf( \\\"ingroup_name defined %s, make_group_also 0, primary_gid %s\\\\n\\\", $gid_option, $primary_gid );\",\n    \"        }\",\n    \"        debugf( \\\"make_group_also %s, primary_gid %s\\\\n\\\", $make_group_also, $primary_gid );\",\n    \"        if( defined( $primary_gid) && $primary_gid == -1 && $make_group_also == 0 ) {\",\n    \"            if (defined($config{\\\"users_gid\\\"}) && $config{\\\"users_gid\\\"} != -1) {\",\n    \"                my @grgid=getgrgid($config{\\\"users_gid\\\"});\",\n    \"                my $grname=$grgid[0];\",\n    \"                debugf( \\\"set primary_gid to users_gid %s %s\\\\n\\\", $config{\\\"users_gid\\\"}, $grname);\",\n    \"                $primary_gid = $config{\\\"users_gid\\\"};\",\n    \"            } elsif (defined($config{\\\"users_gid\\\"}) && $config{\\\"users_gid\\\"} == -1) {\",\n    \"                # nothing\",\n    \"            } else {\",\n    \"                my $primary_group=\\\"users\\\";\",\n    \"                if (defined($config{\\\"users_group\\\"})) {\",\n    \"                    $primary_group=$config{\\\"users_group\\\"};\",\n    \"                }\",\n    \"                $primary_gid=getgrnam($primary_group);\",\n    \"                debugf( \\\"set primary_gid to users_group %s %s\\\\n\\\", $primary_gid, $primary_group);\",\n    \"            }\",\n    \"        } else {\",\n    \"            if (defined($config{\\\"users_gid\\\"}) && $config{\\\"users_gid\\\"} != -1) {\",\n    \"                my @grgid=getgrgid($config{\\\"users_gid\\\"});\",\n    \"                my $grname=$grgid[0];\",\n    \"                debugf( \\\"push users_gid %s %s to supplemental_groups\\\\n\\\", $config{\\\"users_gid\\\"}, $grname);\",\n    \"                push(@supplemental_groups, $grname);\",\n    \"            } elsif (defined($config{\\\"users_gid\\\"}) && $config{\\\"users_gid\\\"} == -1) {\",\n    \"                # nothing\",\n    \"            } else {\",\n    \"                my $supp_group=\\\"users\\\";\",\n    \"                if (defined($config{\\\"users_group\\\"})) {\",\n    \"                    $supp_group=$config{\\\"users_group\\\"};\",\n    \"                }\",\n    \"                debugf( \\\"push %s to supplemental_groups\\\\n\\\", $supp_group );\",\n    \"                push(@supplemental_groups, $supp_group);\",\n    \"            }\",\n    \"        }\",\n    \"    } else {\",\n    \"        debugf( \\\"config usergroups != yes code path\\\\n\\\" );\",\n    \"        if( defined($ingroup_name) ) {\",\n    \"            $primary_gid=getgrnam($ingroup_name);\",\n    \"        } elsif (defined($config{\\\"users_gid\\\"})) {\",\n    \"            debugf( \\\"primary_gid = users_gid = %d\\\\n\\\", $primary_gid );\",\n    \"            $primary_gid = $config{\\\"users_gid\\\"};\",\n    \"        } else {\",\n    \"            if (defined($config{\\\"users_group\\\"})) {\",\n    \"                my @grgid=getgrnam($config{\\\"users_group\\\"});\",\n    \"                my $grgid=$grgid[2];\",\n    \"                debugf( \\\"primary_gid = users_group %s %s\\\\n\\\", $config{\\\"users_group\\\"}, $grgid);\",\n    \"                $primary_gid = $grgid;\",\n    \"            } else {\",\n    \"                debugf( \\\"primary_gid = literal 100\\\\n\\\");\",\n    \"                $primary_gid = 100;\",\n    \"            }\",\n    \"        }\",\n    \"        if( $primary_gid == -1 ) {\",\n    \"            dief( \\\"no primary GID for user set. User not created.\\\\n\\\" );\",\n    \"        }\",\n    \"    }\",\n    \"    debugf( \\\"primary_gid %s, supplemental groups %s\\\\n\\\", $primary_gid, join(\\\", \\\",@supplemental_groups) );\",\n    \"    if ( defined $ingroup_name || defined $gid_option ) {\",\n    \"        $make_group_also = 0;\",\n    \"        debugf( \\\"set make_group_also 0, neither ingroup_name or gid_option defined\\\\n\\\" );\",\n    \"    }\",\n    \"    check_user_group(0);\",\n    \"    $first_uid = $new_firstuid || $config{\\\"first_uid\\\"};\",\n    \"    $last_uid = $new_lastuid || $config{\\\"last_uid\\\"};\",\n    \"    if ($config{\\\"usergroups\\\"} =~  /yes/i) {\",\n    \"        $first_gid = $first_uid;\",\n    \"        $last_gid = $last_uid;\",\n    \"    } else {\",\n    \"        $first_gid = $new_firstgid || $config{\\\"first_gid\\\"};\",\n    \"        $last_gid = $new_lastgid || $config{\\\"last_gid\\\"};\",\n    \"    }\",\n    \"    debugf( \\\"first_uid %s, last_uid %s, first_gid %s, last_gid %s\\\\n\\\", $first_uid, $last_uid, $first_gid, $last_gid );\",\n    \"    printf (gtx(\\\"Adding user `%s' ...\\\\n\\\"),$new_name) if $verbose;\",\n    \"    if (!defined($new_uid)) {\",\n    \"        if ( defined $ingroup_name ) {\",\n    \"            $new_uid = &first_avail_uid( $first_uid,\",\n    \"                                             $last_uid,\",\n    \"                                             $uid_pool{$new_name}{'id'});\",\n    \"        } else {\",\n    \"            my $first_uidgid = ($first_uid, $first_gid)[$first_uid > $first_gid];\",\n    \"            my $last_uidgid  = ($last_uid, $last_gid)[$last_uid < $last_gid];\",\n    \"            # TODO: Check what happens when those ranges do not overlap\",\n    \"            $new_uid = &first_avail_uid_gid( $first_uidgid,\",\n    \"                                             $last_uidgid,\",\n    \"                                             $uid_pool{$new_name}{'id'});\",\n    \"            debugf( \\\"uidgid=%s, from first_uidgid %s, last_uidgid %s\\\\n\\\", $new_uid, $first_uidgid, $last_uidgid);\",\n    \"        }\",\n    \"        # TODO: user can specify different UID and GID here.\",\n    \"        # idea: split handling in uid/gid, which are equally the return value of\",\n    \"        # first_avail_uid_gid. If either pool_id is defined, set uid and gid from\",\n    \"        # distinct first_avail_uid and first_avail_gid calls.\",\n    \"        debugf( \\\"new_uid %s selected\\\\n\\\", $new_uid);\",\n    \"        if ($new_uid == -1) {\",\n    \"            warnf gtx(\\\"No UID/GID pair is available in the range %d-%d (FIRST_UID - LAST_UID).\\\\n\\\"),$first_uid,$last_uid;\",\n    \"            dief (gtx(\\\"The user `%s' was not created.\\\\n\\\"),$new_name);\",\n    \"        }\",\n    \"        debugf( \\\"gid_option %s, ingroup_name %s\\\\n\\\", $gid_option, $ingroup_name );\",\n    \"        if ( defined $gid_option && $gid_option == -1 && defined $ingroup_name && $ingroup_name == \\\"\\\") {\",\n    \"            warnf gtx(\\\"USERGROUPS=no, USER_GID=-1 and USERS_GROUP empty. A user needs a primary group!\\\\n\\\");\",\n    \"            dief (gtx(\\\"The user `%s' was not created.\\\\n\\\"), $new_name);\",\n    \"        } elsif (defined($gid_option) && $gid_option != -1) {\",\n    \"            $ingroup_name = getgrgid($gid_option);\",\n    \"            $primary_gid = $gid_option;\",\n    \"            debugf( \\\"gid_option defined and not -1, ingroup_name %s, primary_gid %d\\\\n\\\", $ingroup_name, $primary_gid );\",\n    \"        } elsif ($ingroup_name) {\",\n    \"            $primary_gid = getgrnam($ingroup_name);\",\n    \"            debugf( \\\"ingroup_name defined %s, primary_gid %d\\\\n\\\", $ingroup_name, $primary_gid );\",\n    \"        } elsif ( defined( $primary_gid ) ) {\",\n    \"            $ingroup_name = getgrgid($primary_gid);\",\n    \"            debugf( \\\"primary_gid defined %d, ingroup_name %s\\\\n\\\", $primary_gid, $primary_gid  );\",\n    \"        } else {\",\n    \"            $ingroup_name = 'users';\",\n    \"            $primary_gid = 100;\",\n    \"            debugf( \\\"ingroup_name hard users, primary_gid hard 100\\\\n\\\" );\",\n    \"        }\",\n    \"        if ($make_group_also) {\",\n    \"            $primary_gid = $new_uid;\",\n    \"            $ingroup_name = $new_name;\",\n    \"            debugf( \\\"make_group_also %s, primary_gid %s, ingroup_name %s\\\\n\\\", $make_group_also, $primary_gid, $ingroup_name );\",\n    \"        }\",\n    \"    } else {\",\n    \"        debugf( \\\"new_uid %s, primary_gid %s, ingroup_name %s, make_group_also %s\\\\n\\\", $new_uid, $primary_gid, $ingroup_name, $make_group_also );\",\n    \"        if (defined($gid_option)) {\",\n    \"            $ingroup_name = getgrgid($gid_option);\",\n    \"            $primary_gid = $gid_option;\",\n    \"            debugf( \\\"gid_option defined %s, ingroup_name %s\\\\n\\\", $gid_option, $ingroup_name );\",\n    \"        } elsif (defined($primary_gid) && $primary_gid != -1) {\",\n    \"            $ingroup_name = getgrgid($primary_gid);\",\n    \"            debugf( \\\"primary_gid defined %s, ingroup_name %s\\\\n\\\", $primary_gid, $ingroup_name );\",\n    \"        } elsif ($ingroup_name) {\",\n    \"            $primary_gid = getgrnam($ingroup_name);\",\n    \"            debugf( \\\"ingroup_name defined %s, primary_gid %s\\\\n\\\", $ingroup_name, $primary_gid );\",\n    \"        } elsif ($make_group_also) {\",\n    \"            $primary_gid=$new_uid; $ingroup_name=$new_name;\",\n    \"            debugf( \\\"make_group_also %s, primary_gid defined %s, ingroup_name %s\\\\n\\\", $make_group_also, $primary_gid, $ingroup_name );\",\n    \"        } else {\",\n    \"            debugf( \\\"no gid_option, no primary_gid, no ingroup_name, no make_group_also\\\\n\\\" );\",\n    \"            dief (gtx(\\\"Internal error interpreting parameter combination\\\\n\\\"));\",\n    \"        }\",\n    \"    }\",\n    \"    debugf (\\\"make_group_also %s\\\\n\\\", $make_group_also );\",\n    \"    if ($make_group_also) {\",\n    \"        $undogroup = $new_name;\",\n    \"        my $groupadd = &which('groupadd');\",\n    \"        if( defined( $primary_gid ) ) {\",\n    \"           printf (gtx(\\\"Adding new group `%s' (%d) ...\\\\n\\\"),$new_name,$primary_gid) if $verbose;\",\n    \"           &systemcall($groupadd, '-g', $primary_gid, $new_name);\",\n    \"        } else {\",\n    \"           printf (gtx(\\\"Adding new group `%s' (new group ID) ...\\\\n\\\"),$new_name) if $verbose;\",\n    \"           &systemcall($groupadd, $new_name);\",\n    \"           $primary_gid = getgrnam($new_name);\",\n    \"           debugf( \\\"new group '%s' created with GID %d\\\", $new_name, $primary_gid );\",\n    \"        }\",\n    \"    }\",\n    \"    if ($verbose) {\",\n    \"        my @grgid=getgrgid($primary_gid);\",\n    \"        my $grname=$grgid[0];\",\n    \"        printf gtx(\\\"Adding new user `%s' (%d) with group `%s (%d)' ...\\\\n\\\"),$new_name,$new_uid,$grname,$primary_gid;\",\n    \"    }\",\n    \"    $home_dir = $special_home || $uid_pool{$new_name}{'home'} || &homedir($new_name, $ingroup_name);\",\n    \"    if( !$disabled_login ) {\",\n    \"        $shell = $special_shell || $uid_pool{$new_name}{'shell'} || $config{\\\"dshell\\\"};\",\n    \"    } else {\",\n    \"        $shell = $special_shell || $uid_pool{$new_name}{'shell'} || \\\"/usr/sbin/nologin\\\";\",\n    \"    }\",\n    \"    $undouser = $new_name;\",\n    \"    my $useradd = &which('useradd');\",\n    \"    &systemcall($useradd, '-d', $home_dir, '-g', $primary_gid, '-s',\",\n    \"                $shell, '-u', $new_uid, $new_name);\",\n    \"    create_homedir (1); # copy skeleton data\",\n    \"    # useradd without -p has left the account disabled (password string is '!')\",\n    \"    my $yesexpr = langinfo(YESEXPR());\",\n    \"    my $noexpr = langinfo(NOEXPR());\",\n    \"    if ($ask_passwd) {\",\n    \"        PASSWD: for (;;) {\",\n    \"            my $passwd = &which('passwd');\",\n    \"            # do _not_ use systemcall() here, since systemcall() dies on\",\n    \"            # non-zero exit code and we need to do special handling here!\",\n    \"            system($passwd, $new_name);\",\n    \"            my $ok = $?>>8;\",\n    \"            if ($ok != 0) {\",\n    \"                my $answer;\",\n    \"                # hm, error, should we break now?\",\n    \"                warnf (gtx(\\\"Permission denied\\\\n\\\")) if ($ok == 1);\",\n    \"                warnf (gtx(\\\"invalid combination of options\\\\n\\\")) if ($ok == 2);\",\n    \"                warnf (gtx(\\\"unexpected failure, nothing done\\\\n\\\")) if ($ok == 3);\",\n    \"                warnf (gtx(\\\"unexpected failure, passwd file missing\\\\n\\\")) if ($ok == 4);\",\n    \"                warnf (gtx(\\\"passwd file busy, try again\\\\n\\\")) if ($ok == 5);\",\n    \"                warnf (gtx(\\\"invalid argument to option\\\\n\\\")) if ($ok == 6);\",\n    \"                # Translators: [y/N] has to be replaced by values defined in your\",\n    \"                # locale.  You can see by running \\\"locale noexpr\\\" which regular\",\n    \"                # expression will be checked to find positive answer.\",\n    \"                PROMPT: for (;;) {\",\n    \"                    print (gtx(\\\"Try again? [y/N] \\\"));\",\n    \"                    chop ($answer=<STDIN>);\",\n    \"                    last PROMPT if ($answer =~ m/$yesexpr/o);\",\n    \"                    last PASSWD if ($answer =~ m/$noexpr/o);\",\n    \"                    last PASSWD if (!$answer);\",\n    \"                }\",\n    \"            } else {\",\n    \"                last; ## passwd ok\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"    if (defined($new_comment)) {\",\n    \"        &ch_comment($new_comment);\",\n    \"    } elsif ($uid_pool{$new_name}{'comment'}) {\",\n    \"        &ch_comment($uid_pool{$new_name}{'comment'});\",\n    \"    } else {\",\n    \"        my $noexpr = langinfo(NOEXPR());\",\n    \"        my $yesexpr = langinfo(YESEXPR());\",\n    \"        CHFN: for (;;) {\",\n    \"            my $chfn = &which('chfn');\",\n    \"            &systemcall($chfn, $new_name);\",\n    \"            # Translators: [y/N] has to be replaced by values defined in your\",\n    \"            # locale.  You can see by running \\\"locale yesexpr\\\" which regular\",\n    \"            # expression will be checked to find positive answer.\",\n    \"            PROMPT: for (;;) {\",\n    \"                print (gtx(\\\"Is the information correct? [Y/n] \\\"));\",\n    \"                chop (my $answer=<STDIN>);\",\n    \"                last PROMPT if ($answer =~ m/$noexpr/o);\",\n    \"                last CHFN if ($answer =~ m/$yesexpr/o);\",\n    \"                last CHFN if (!$answer);\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"    if ( ( $add_extra_groups || $config{\\\"add_extra_groups\\\"} ) && defined($config{\\\"extra_groups\\\"}) ) {\",\n    \"        push (@supplemental_groups, split(/\\\\s+/,$config{\\\"extra_groups\\\"}));\",\n    \"    }\",\n    \"    if ( @supplemental_groups ) {\",\n    \"        if ($verbose) {\",\n    \"            printf (gtx(\\\"Adding new user `%s' to supplemental / extra groups `%s' ...\\\\n\\\"), $new_name, join(\\\", \\\", @supplemental_groups));\",\n    \"        }\",\n    \"        foreach my $newgrp ( @supplemental_groups ) {\",\n    \"            debugf( \\\"newgrp %s\\\\n\\\", $newgrp);\",\n    \"            if (!defined getgrnam($newgrp)) {\",\n    \"                warnf (gtx(\\\"The group `%s' does not exist.\\\\n\\\"),$newgrp);\",\n    \"                next;\",\n    \"            }\",\n    \"            if (&user_is_member($new_name, $newgrp)) {\",\n    \"                warnf gtx(\\\"The user `%s' is already a member of `%s'.\\\\n\\\"),\",\n    \"                        $new_name,$newgrp if $verbose;\",\n    \"                next;\",\n    \"            }\",\n    \"            printf gtx(\\\"Adding user `%s' to group `%s' ...\\\\n\\\"),$new_name,$newgrp\",\n    \"                if $verbose;\",\n    \"            my $gpasswd = &which('gpasswd');\",\n    \"            &systemcall($gpasswd, '-M',\",\n    \"                        join(',', get_group_members($newgrp), $new_name),\",\n    \"                        $newgrp);\",\n    \"        }\",\n    \"    }\",\n    \"    if ($config{\\\"quotauser\\\"}) {\",\n    \"        printf (gtx(\\\"Setting quota for user `%s' to values of user `%s' ...\\\\n\\\"), $new_name, $config{quotauser});\",\n    \"        my $edquota = &which('edquota');\",\n    \"        &systemcall($edquota, '-p', $config{quotauser}, $new_name);\",\n    \"    }\",\n    \"    &systemcall('/usr/local/sbin/adduser.local', $new_name, $new_uid,\",\n    \"            $primary_gid, $home_dir) if (-x \\\"/usr/local/sbin/adduser.local\\\");\",\n    \"    release_lock(0);\",\n    \"    exit RET_OK;\",\n    \"# we never go here\",\n    \"# calculate home directory\",\n    \"sub homedir {\",\n    \"    my $dir = $config{\\\"dhome\\\"};\",\n    \"    $dir .= '/' . $_[1] if ($config{\\\"grouphomes\\\"} =~ /yes/i);\",\n    \"    $dir .= '/' . substr($_[0],0,1) if ($config{\\\"letterhomes\\\"} =~ /yes/i);\",\n    \"    $dir .= '/' . $_[0];\",\n    \"    return $dir;\",\n    \"# create_homedir -- create the homedirectory\",\n    \"# parameter\",\n    \"#   1: $copy_skeleton:\",\n    \"#     if 0  -> don't copy the skeleton data\",\n    \"#     if 1  -> copy the files in /etc/skel to the newly created home directory\",\n    \"# return values:\",\n    \"#   none\",\n    \"sub create_homedir {\",\n    \"    my ($copy_skeleton) = @_;\",\n    \"    if ($home_dir =~ /^\\\\/+nonexistent(\\\\/|$)/) {\",\n    \"        printf gtx(\\\"Not creating `%s'.\\\\n\\\"), $home_dir if $verbose;\",\n    \"    }\",\n    \"    elsif ($no_create_home) {\",\n    \"        printf gtx(\\\"Not creating home directory `%s'.\\\\n\\\"), $home_dir if $verbose;\",\n    \"    }\",\n    \"    elsif (-e $home_dir) {\",\n    \"        warnf gtx(\\\"The home directory `%s' already exists.  Not touching this directory.\\\\n\\\"),\",\n    \"        $home_dir if $verbose && !$no_create_home;\",\n    \"        my @homedir_stat = stat($home_dir);\",\n    \"        my $home_uid = $homedir_stat[4];\",\n    \"        my $home_gid = $homedir_stat[5];\",\n    \"        if (($home_uid != $new_uid) || ($home_gid != $primary_gid)) {\",\n    \"            warnf gtx(\\\"Warning: The home directory `%s' does not belong to the user you are currently creating.\\\\n\\\"), $home_dir;\",\n    \"        }\",\n    \"        undef @homedir_stat; undef $home_uid; undef $home_gid;\",\n    \"    } else {\",\n    \"        printf gtx(\\\"Creating home directory `%s' ...\\\\n\\\"),$home_dir if $verbose;\",\n    \"        $undohome = $home_dir;\",\n    \"        &mktree($home_dir) || &cleanup(sprintf(gtx(\\\"Couldn't create home directory `%s': %s.\\\\n\\\"), $home_dir, $!));\",\n    \"        chown($new_uid, $primary_gid, $home_dir)\",\n    \"        || &cleanup(\\\"chown $new_uid:$primary_gid $home_dir: $!\\\\n\\\");\",\n    \"        $dir_mode = get_dir_mode();\",\n    \"        chmod ($dir_mode, $home_dir) ||\",\n    \"        &cleanup(\\\"chmod $dir_mode $home_dir: $!\\\\n\\\");\",\n    \"        if ($config{\\\"skel\\\"} && $copy_skeleton) {\",\n    \"            printf gtx(\\\"Copying files from `%s' ...\\\\n\\\"),$config{skel} if $verbose;\",\n    \"            open(my $FIND, \\\"cd $config{skel}; find .  -print |\\\")\",\n    \"                || &cleanup(sprintf(gtx(\\\"fork for `find' failed: %s\\\\n\\\"), $!));\",\n    \"            while (<$FIND>) {\",\n    \"                chop;\",\n    \"                next if ($_ eq \\\".\\\");\",\n    \"                next if ($_ =~ qr/$config{skel_ignore_regex}/ );\",\n    \"                &copy_to_dir($config{\\\"skel\\\"}, $_, $home_dir, $new_uid,\",\n    \"                    $primary_gid, ($config{\\\"setgid_home\\\"} =~ /yes/i));\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"# mktree: create a directory and all parent directories, we don't care about the rights and so on\",\n    \"# parameters:\",\n    \"#   tree: the path\",\n    \"# return values:\",\n    \"#   none\",\n    \"sub mktree {\",\n    \"    my($tree) = @_;\",\n    \"    my($done, @path);\",\n    \"    my $default_dir_mode = 0755;\",\n    \"    $tree =~ s:^/*(.*)/*$:$1:; # chop off leading & trailing slashes\",\n    \"    @path = split(/\\\\//, $tree);\",\n    \"    $done = \\\"\\\";\",\n    \"    while (@path) {\",\n    \"        $done .= '/' . shift(@path);\",\n    \"        -d $done || mkdir($done, $default_dir_mode) || return 0;\",\n    \"    }\",\n    \"    return 1;\",\n    \"# existing_user_ok: check if there's already a user present on the system which satisfies the requirements\",\n    \"# parameter:\",\n    \"#   new_name: the name of the user to check\",\n    \"#   new_uid : the UID of the user\",\n    \"# return values:\",\n    \"#   0 if the the user doesn't exist\",\n    \"#   1 if the user already exists with the specified uid (or $new_uid wasn't specified)\",\n    \"#   2 if the user already exists, but $new_uid doesn't matches its uid\",\n    \"sub existing_user_ok {\",\n    \"    my($new_name,$new_uid) = @_;\",\n    \"    my ($dummy1,$dummy2,$uid);\",\n    \"    if (($dummy1,$dummy2,$uid) = getpwnam($new_name)) {\",\n    \"        if( defined($new_uid) && $uid == $new_uid ) {\",\n    \"            return 1;\",\n    \"        }\",\n    \"        if (! defined($new_uid)) {\",\n    \"            return 1;\",\n    \"        }\",\n    \"        # TODO: do we really need this code? Range check shouldn't performed here\",\n    \"        # also, we might be checking a normal user as well here\",\n    \"        if( $uid >= $config{\\\"first_system_uid\\\"} &&\",\n    \"            $uid <= $config{\\\"last_system_uid\\\" } ) {\",\n    \"            return 2;\",\n    \"        }\",\n    \"    } else {\",\n    \"        return 0;\",\n    \"    }\",\n    \"# existing_group_ok: check if there's already a group which satiesfies the requirements\",\n    \"# parameter:\",\n    \"#   new_name: the name of the group\",\n    \"#   new_gid : the GID of the group\",\n    \"# return values:\",\n    \"#   0 if the group doesn't exist\",\n    \"#   1 if the group already exists with the specified gid (or $gid_option wasn't specified)\",\n    \"#   2 if the group already exists, but $gid_option doesn't match its gid\",\n    \"#   3 if the group already exists inside the system range\",\n    \"sub existing_group_ok {\",\n    \"    my($new_name,$new_gid) = @_;\",\n    \"    my ($dummy1,$dummy2,$gid);\",\n    \"    if (($dummy1,$dummy2,$gid) = getgrnam($new_name)) {\",\n    \"        # TODO: is this check required? There shouldn't be any gid outside of our allowed range anyways ...\",\n    \"        # also, we might be checking a normal user as well here\",\n    \"        if( $gid >= $config{\\\"first_system_gid\\\"} &&\",\n    \"            $gid <= $config{\\\"last_system_gid\\\" } ) {\",\n    \"            return 3;\",\n    \"        }\",\n    \"        if (! defined($new_gid)) {\",\n    \"            return 1;\",\n    \"        }\",\n    \"        if ($gid == $new_gid) {\",\n    \"            return 1;\",\n    \"        } else {\",\n    \"            return 2;\",\n    \"        }\",\n    \"    } else {\",\n    \"        return 0;\",\n    \"    }\",\n    \"# check_user_group: ???\",\n    \"# parameters:\",\n    \"#   system: 0 if the user isn't a system user, 1 otherwise\",\n    \"# return values:\",\n    \"# todo: not sure whether global variables apply fine here.\",\n    \"sub check_user_group {\",\n    \"    my ($system) = @_;\",\n    \"    debugf( \\\"check_user_group %s called, make_group_also %s\\\\n\\\", $system, $make_group_also );\",\n    \"    if( !$system || !existing_user_ok($new_name, $new_uid) ) {\",\n    \"        if( defined getpwnam($new_name) ) {\",\n    \"            if( $system ) {\",\n    \"                dief (gtx(\\\"The user `%s' already exists, and is not a system user.\\\\n\\\"),$new_name);\",\n    \"            } else {\",\n    \"                dief (gtx(\\\"The user `%s' already exists.\\\\n\\\"),$new_name);\",\n    \"            }\",\n    \"        }\",\n    \"        dief (gtx(\\\"The UID %d is already in use.\\\\n\\\"),$new_uid)\",\n    \"            if (defined($new_uid) && getpwuid($new_uid));\",\n    \"    }\",\n    \"    if ($make_group_also) {\",\n    \"        debugf( \\\"make_group_also 1, new_name %s, new_uid %s\\\\n\\\", $new_name, $new_uid );\",\n    \"        if( !$system || !existing_group_ok($new_name, $new_uid) ) {\",\n    \"            dief (gtx(\\\"The group `%s' already exists.\\\\n\\\"),$new_name)\",\n    \"                if (defined getgrnam($new_name));\",\n    \"            dief (gtx(\\\"The GID %d is already in use.\\\\n\\\"),$new_uid)\",\n    \"                if (defined($new_uid) && defined(getgrgid($new_uid)));\",\n    \"        }\",\n    \"    } else {\",\n    \"        dief (gtx(\\\"The group `%s' does not exist.\\\\n\\\"),$ingroup_name)\",\n    \"            if ($ingroup_name && !defined(getgrnam($ingroup_name)));\",\n    \"        dief (gtx(\\\"The GID %d does not exist.\\\\n\\\"),$gid_option)\",\n    \"            if (defined($gid_option) && !defined(getgrgid($gid_option)));\",\n    \"    }\",\n    \"    debugf( \\\"return from check_user_group\\\\n\\\" );\",\n    \"# copy_to_dir :\",\n    \"# parameters:\",\n    \"#   fromdir\",\n    \"#   file\",\n    \"#   todir\",\n    \"#   newi\",\n    \"#   newg\",\n    \"#   sgiddir\",\n    \"# return values:\",\n    \"#   none\",\n    \"sub copy_to_dir {\",\n    \"    my($fromdir, $file, $todir, $newu, $newg, $sgiddir) = @_;\",\n    \"    if (-l \\\"$fromdir/$file\\\") {\",\n    \"        my $target=readlink(\\\"$fromdir/$file\\\") or &cleanup(\\\"readlink: $!\\\\n\\\");\",\n    \"        my $curgid=\\\"$)\\\";\",\n    \"        my $curuid=\\\"$>\\\";\",\n    \"        my $error=\\\"\\\";\",\n    \"        $)=\\\"$newg\\\";\",\n    \"        $>=\\\"$newu\\\";\",\n    \"        symlink(\\\"$target\\\", \\\"$todir/$file\\\") or $error=\\\"$!\\\";\",\n    \"        $>=\\\"$curuid\\\";\",\n    \"        $)=\\\"$curgid\\\";\",\n    \"        if( \\\"$error\\\" ne \\\"\\\" ) {\",\n    \"            &cleanup(\\\"symlink: $!\\\\n\\\");\",\n    \"        }\",\n    \"        return;\",\n    \"    } elsif (-f \\\"$fromdir/$file\\\") {\",\n    \"        open (FILE, \\\"$fromdir/$file\\\") || &cleanup(\\\"open $fromdir/$file: $!\\\");\",\n    \"        open (NEWFILE, \\\">$todir/$file\\\") || &cleanup(\\\"open >$todir/$file: $!\\\");\",\n    \"        (print NEWFILE <FILE>) || &cleanup(\\\"print $todir/$file: $!\\\");\",\n    \"        close FILE;\",\n    \"        close(NEWFILE)  || &cleanup(\\\"close $todir/$file \\\");\",\n    \"    } elsif (-d \\\"$fromdir/$file\\\") {\",\n    \"        mkdir(\\\"$todir/$file\\\", 700) || &cleanup(\\\"mkdir: $!\\\");\",\n    \"    } else {\",\n    \"        &cleanup(sprintf((gtx(\\\"Cannot deal with %s.\\\\nIt is not a dir, file, or symlink.\\\\n\\\")), \\\"$fromdir/$file\\\"));\",\n    \"    }\",\n    \"    chown($newu, $newg, \\\"$todir/$file\\\")\",\n    \"        || &cleanup(\\\"chown $newu:$newg $todir/$file: $!\\\\n\\\");\",\n    \"    $perm = (stat(\\\"$fromdir/$file\\\"))[2] & 07777;\",\n    \"    $perm |= 02000 if (-d \\\"$fromdir/$file\\\" && ($perm & 010) && $sgiddir);\",\n    \"    chmod($perm, \\\"$todir/$file\\\") || &cleanup(\\\"chmod $todir/$file: $!\\\\n\\\");\",\n    \"# checkname: perform some sanity checks\",\n    \"# parameters:\",\n    \"#   name: the name to check\",\n    \"# return values:\",\n    \"#   none (exits on error)\",\n    \"sub checkname {\",\n    \"    my ($name) = @_;\",\n    \"    my $ieee_regex = '^[_.A-Za-z0-9][-\\\\@_.A-Za-z0-9]*\\\\$?$';\",\n    \"    my $min_regex = qr{^[^-+~:,\\\\s/][^:,\\\\s/]*$};\",\n    \"    my $name_regex_var = $found_sys_opt ? 'SYS_NAME_REGEX' : 'NAME_REGEX';\",\n    \"    my $name_regex = $config{lc $name_regex_var};\",\n    \"    if ($name =~ /^[\\\\d]+$/) {\",\n    \"        # this check cannot be turned off\",\n    \"        warnf gtx(\\\"To avoid ambiguity with numerical UIDs, usernames which\",\n    \"            consist of only digits are not allowed.\\\\n\\\");\",\n    \"        exit RET_INVALID_CHARS_IN_NAME;\",\n    \"    }\",\n    \"    if (length $name > 32) {\",\n    \"        # this check cannot be turned off\",\n    \"        warnf gtx(\\\"Usernames must be no more than 32 bytes in length;\",\n    \"            note that if you are using Unicode characters, the character\",\n    \"            limit will be less than 32.\\\\n\\\");\",\n    \"        exit RET_INVALID_CHARS_IN_NAME;\",\n    \"    }\",\n    \"    if ($name !~ $min_regex) {\",\n    \"        # this check cannot be turned off\",\n    \"        warnf gtx(\\\"To avoid problems, the username must not start with a\",\n    \"            dash, plus sign, or tilde, and it must not contain any of the\",\n    \"            following: colon, comma, slash, or any whitespace characters\",\n    \"            including spaces, tabs, and newlines.\\\\n\\\");\",\n    \"        exit RET_INVALID_CHARS_IN_NAME;\",\n    \"    }\",\n    \"    return if ($name =~ qr/$name_regex/);\",\n    \"    if ($name !~ $ieee_regex && $name_check_level < 2) {\",\n    \"        warnf (gtx(\\\"To avoid problems, the username should consist only of\",\n    \"            letters, digits, underscores, periods, at signs and dashes, and\",\n    \"            not start with a dash (as defined by IEEE Std 1003.1-2001). For\",\n    \"            compatibility with Samba machine accounts, \\\\$ is also supported\",\n    \"            at the end of the username.  (Use the `--allow-all-names' option\",\n    \"            to bypass this restriction.)\\\\n\\\"));\",\n    \"        exit RET_INVALID_CHARS_IN_NAME;\",\n    \"    }\",\n    \"    if ($name_check_level) {\",\n    \"        print (gtx(\\\"Allowing use of questionable username.\\\\n\\\")) if ($verbose);\",\n    \"    } else {\",\n    \"        warnf (gtx(\\\"Please enter a username matching the regular expression\",\n    \"            configured via the %s configuration variable.  Use the\",\n    \"            `--allow-bad-names' option to relax this check or reconfigure\",\n    \"            %s in configuration.\\\\n\\\"), $name_regex_var, $name_regex_var);\",\n    \"        exit RET_INVALID_CHARS_IN_NAME;\",\n    \"    }\",\n    \"# first_avail_uid: return the first available uid in given range\",\n    \"# parameters:\",\n    \"#   min, max: the range\",\n    \"#   pool_id: user id suggested from pool\",\n    \"# return values:\",\n    \"#   -1 if no free uid is available\",\n    \"#  otherwise the choosen uid\",\n    \"sub first_avail_uid {\",\n    \"    my ($min, $max, $pool_id) = @_;\",\n    \"    if (defined ($pool_id)) {\",\n    \"        return $pool_id if (!defined(getpwuid($pool_id)));\",\n    \"        return -1;\",\n    \"    }\",\n    \"    printf (gtx(\\\"Selecting UID from range %d to %d ...\\\\n\\\"),$min,$max) if ($verbose > 1);\",\n    \"    my $t = $min;\",\n    \"    while ($t <= $max) {\",\n    \"       return $t if (!defined(getpwuid($t)));\",\n    \"       $t++;\",\n    \"    }\",\n    \"    return -1; # nothing available\",\n    \"# first_avail_gid: return the first available gid in given range\",\n    \"# parameters:\",\n    \"#   min, max: the range\",\n    \"#   pool_id: group id suggested from pool\",\n    \"# return values:\",\n    \"#   -1 if no free gid is available\",\n    \"#   otherwise the choosen gid\",\n    \"sub first_avail_gid {\",\n    \"    my ($min, $max, $pool_id) = @_;\",\n    \"    if (defined ($pool_id)) {\",\n    \"        return $pool_id if (!defined(getgrgid($pool_id)));\",\n    \"        return -1;\",\n    \"    }\",\n    \"    printf (gtx(\\\"Selecting GID from range %d to %d ...\\\\n\\\"),$min,$max) if ($verbose > 1);\",\n    \"    my $t = $min;\",\n    \"    while ($t <= $max) {\",\n    \"       return $t if (!defined(getgrgid($t)));\",\n    \"       $t++;\",\n    \"    }\",\n    \"    return -1; # nothing available\",\n    \"# first_avail_uid_gid: return the first available id in given range\",\n    \"#     that is both available as uid and gid\",\n    \"# parameters:\",\n    \"#   min, max: the range\",\n    \"#   pool_id: user id suggested from pool\"\n  ],\n  \"hex_dump\": null,\n  \"binary_info\": null,\n  \"signatures\": null,\n  \"symbols\": null,\n  \"control_flow\": null,\n  \"vulnerabilities\": null,\n  \"code_quality\": null,\n  \"dependencies\": null,\n  \"entropy\": {\n    \"overall_entropy\": 4.858835656328449,\n    \"sections\": [\n      {\n        \"name\": \"entire_file\",\n        \"offset\": 0,\n        \"size\": 48382,\n        \"entropy\": 4.858835656328449,\n        \"is_suspicious\": false,\n        \"characteristics\": [\n          \"Raw entropy: 4.86\"\n        ]\n      }\n    ],\n    \"packed_indicators\": {\n      \"likely_packed\": false,\n      \"packer_signatures\": [],\n      \"compression_ratio_estimate\": 0.0,\n      \"import_table_anomalies\": [],\n      \"section_anomalies\": [],\n      \"entry_point_suspicious\": false\n    },\n    \"encryption_indicators\": {\n      \"likely_encrypted\": false,\n      \"high_entropy_regions\": [],\n      \"crypto_constants_found\": [],\n      \"random_data_percentage\": 0.027758257203092107\n    },\n    \"obfuscation_score\": 18.220633711231685,\n    \"recommendations\": [\n      \"No significant obfuscation detected. Standard analysis should be effective.\"\n    ]\n  },\n  \"disassembly\": null,\n  \"threats\": null,\n  \"behavioral\": null,\n  \"yara_indicators\": null\n}"}]}}