use file_scanner::vulnerability_detection::*;
use file_scanner::control_flow::{
    AnalysisStats, BasicBlock, BlockType, ControlFlowAnalysis, ControlFlowGraph,
    ControlFlowMetrics, FlowControl, Instruction, InstructionType, Loop, LoopType, OverallMetrics,
};
use file_scanner::function_analysis::{ImportInfo, SymbolCounts, SymbolTable};


// Helper function to create mock instructions
fn create_instruction(
    address: u64,
    mnemonic: &str,
    operands: &str,
    instruction_type: InstructionType,
    flow_control: FlowControl,
) -> Instruction {
    Instruction {
        address,
        bytes: vec![0x90; 4], // NOP bytes
        mnemonic: mnemonic.to_string(),
        operands: operands.to_string(),
        instruction_type,
        flow_control,
        size: 4,
    }
}

// Helper function to create mock basic blocks
fn create_basic_block(id: usize, instructions: Vec<Instruction>) -> BasicBlock {
    let start_address = instructions.first().map(|i| i.address).unwrap_or(0);
    let end_address = instructions.last().map(|i| i.address).unwrap_or(0) + 4;
    let instruction_count = instructions.len();

    BasicBlock {
        id,
        start_address,
        end_address,
        instructions,
        predecessors: Vec::new(),
        successors: Vec::new(),
        block_type: BlockType::Normal,
        instruction_count,
    }
}

// Helper function to create mock CFG
fn create_cfg(
    function_name: &str,
    function_address: u64,
    basic_blocks: Vec<BasicBlock>,
    cyclomatic_complexity: u32,
    cognitive_complexity: u32,
) -> ControlFlowGraph {
    let complexity = ControlFlowMetrics {
        cyclomatic_complexity,
        cognitive_complexity,
        nesting_depth: 2,
        basic_block_count: basic_blocks.len(),
        edge_count: basic_blocks.len().saturating_sub(1),
        loop_count: 0,
        unreachable_blocks: Vec::new(),
    };

    ControlFlowGraph {
        function_name: function_name.to_string(),
        function_address,
        basic_blocks,
        edges: Vec::new(),
        entry_block: 0,
        exit_blocks: vec![],
        loops: Vec::new(),
        complexity,
    }
}

// Helper function to create mock symbol table
fn create_symbol_table(imports: Vec<ImportInfo>) -> SymbolTable {
    let imported_functions = imports.len();
    SymbolTable {
        functions: Vec::new(),
        global_variables: Vec::new(),
        cross_references: Vec::new(),
        imports,
        exports: Vec::new(),
        symbol_count: SymbolCounts {
            total_functions: 0,
            local_functions: 0,
            imported_functions,
            exported_functions: 0,
            global_variables: 0,
            cross_references: 0,
        },
    }
}

// Helper function to create mock CFG analysis
fn create_cfg_analysis(cfgs: Vec<ControlFlowGraph>) -> ControlFlowAnalysis {
    let total_functions = cfgs.len();
    let total_basic_blocks: usize = cfgs.iter().map(|cfg| cfg.basic_blocks.len()).sum();
    let max_complexity = cfgs
        .iter()
        .map(|cfg| cfg.complexity.cyclomatic_complexity)
        .max()
        .unwrap_or(0);
    let avg_complexity = if cfgs.is_empty() {
        0.0
    } else {
        cfgs.iter()
            .map(|cfg| cfg.complexity.cyclomatic_complexity as f64)
            .sum::<f64>()
            / cfgs.len() as f64
    };
    let function_with_max_complexity = cfgs
        .iter()
        .max_by_key(|cfg| cfg.complexity.cyclomatic_complexity)
        .map(|cfg| cfg.function_name.clone());

    ControlFlowAnalysis {
        cfgs,
        overall_metrics: OverallMetrics {
            total_functions,
            analyzed_functions: total_functions,
            total_basic_blocks,
            average_complexity: avg_complexity,
            max_complexity,
            function_with_max_complexity,
        },
        analysis_stats: AnalysisStats {
            analysis_duration: 100,
            bytes_analyzed: 1024,
            instructions_analyzed: 50,
            errors: Vec::new(),
        },
    }
}

#[test]
fn test_vulnerability_detector_initialization() {
    // Test that VulnerabilityDetector can be created
    let detector = VulnerabilityDetector::new();
    
    // Test the public analyze method with empty data
    let symbol_table = create_symbol_table(vec![]);
    let cfg_analysis = create_cfg_analysis(vec![]);
    
    let result = detector.analyze(&symbol_table, &cfg_analysis);
    assert!(result.is_ok());
    
    let result = result.unwrap();
    // With empty data, should have no vulnerabilities
    assert_eq!(result.vulnerabilities.len(), 0);
}

#[test]
fn test_severity_enum() {
    let severities = vec![
        Severity::Critical,
        Severity::High,
        Severity::Medium,
        Severity::Low,
        Severity::Info,
    ];

    for severity in &severities {
        // Test serialization
        let json = serde_json::to_string(severity).unwrap();
        let deserialized: Severity = serde_json::from_str(&json).unwrap();
        assert_eq!(
            std::mem::discriminant(severity),
            std::mem::discriminant(&deserialized)
        );
    }

    // Test equality
    assert_eq!(Severity::Critical, Severity::Critical);
    assert_ne!(Severity::Critical, Severity::High);
}

#[test]
fn test_vulnerability_category_enum() {
    let categories = vec![
        VulnerabilityCategory::BufferOverflow,
        VulnerabilityCategory::FormatString,
        VulnerabilityCategory::IntegerOverflow,
        VulnerabilityCategory::UseAfterFree,
        VulnerabilityCategory::NullPointerDereference,
        VulnerabilityCategory::RaceCondition,
        VulnerabilityCategory::InjectionVulnerability,
        VulnerabilityCategory::CryptographicWeakness,
        VulnerabilityCategory::MemoryLeak,
        VulnerabilityCategory::DoubleFree,
        VulnerabilityCategory::UncontrolledRecursion,
        VulnerabilityCategory::DivisionByZero,
        VulnerabilityCategory::SignedIntegerOverflow,
        VulnerabilityCategory::UnsafeAPIUsage,
    ];

    // Test all 14 categories exist
    assert_eq!(categories.len(), 14);

    // Test serialization for each
    for category in &categories {
        let json = serde_json::to_string(category).unwrap();
        let deserialized: VulnerabilityCategory = serde_json::from_str(&json).unwrap();
        assert_eq!(
            std::mem::discriminant(category),
            std::mem::discriminant(&deserialized)
        );
    }
}

#[test]
fn test_risk_level_enum() {
    let levels = vec![
        RiskLevel::Critical,
        RiskLevel::High,
        RiskLevel::Medium,
        RiskLevel::Low,
        RiskLevel::Minimal,
    ];

    assert_eq!(levels.len(), 5);

    for level in &levels {
        let json = serde_json::to_string(level).unwrap();
        let deserialized: RiskLevel = serde_json::from_str(&json).unwrap();
        assert_eq!(
            std::mem::discriminant(level),
            std::mem::discriminant(&deserialized)
        );
    }
}

#[test]
fn test_code_location_creation() {
    let location = CodeLocation {
        function_name: "test_func".to_string(),
        function_address: 0x1000,
        instruction_address: 0x1020,
        basic_block_id: 2,
        instruction: "call strcpy".to_string(),
        source_line: Some(42),
    };

    assert_eq!(location.function_name, "test_func");
    assert_eq!(location.function_address, 0x1000);
    assert_eq!(location.instruction_address, 0x1020);
    assert_eq!(location.basic_block_id, 2);
    assert_eq!(location.instruction, "call strcpy");
    assert_eq!(location.source_line, Some(42));
}

#[test]
fn test_detected_vulnerability_creation() {
    let vuln = DetectedVulnerability {
        rule_id: "BOF001".to_string(),
        rule_name: "Buffer Overflow".to_string(),
        severity: Severity::Critical,
        category: VulnerabilityCategory::BufferOverflow,
        description: "Dangerous use of strcpy".to_string(),
        locations: vec![CodeLocation {
            function_name: "main".to_string(),
            function_address: 0x1000,
            instruction_address: 0x1100,
            basic_block_id: 0,
            instruction: "call strcpy".to_string(),
            source_line: None,
        }],
        confidence: 0.9,
        context: "Function uses unsafe string operations".to_string(),
        cve_references: vec!["CVE-2021-44228".to_string()],
        cwe_references: vec!["CWE-120".to_string()],
        mitigation: "Use strncpy instead".to_string(),
    };

    assert_eq!(vuln.rule_id, "BOF001");
    assert_eq!(vuln.locations.len(), 1);
    assert_eq!(vuln.confidence, 0.9);
    assert_eq!(vuln.cve_references.len(), 1);
    assert_eq!(vuln.cwe_references.len(), 1);
}

#[test]
fn test_risk_assessment_creation() {
    let risk = RiskAssessment {
        overall_risk_score: 7.5,
        critical_count: 2,
        high_count: 3,
        medium_count: 5,
        low_count: 10,
        total_vulnerabilities: 20,
        risk_level: RiskLevel::High,
        recommendations: vec![
            "Fix critical issues immediately".to_string(),
            "Address high priority issues within 24 hours".to_string(),
        ],
    };

    assert_eq!(risk.overall_risk_score, 7.5);
    assert_eq!(risk.total_vulnerabilities, 20);
    assert_eq!(risk.recommendations.len(), 2);
    assert!(matches!(risk.risk_level, RiskLevel::High));
}

#[test]
fn test_detection_stats_creation() {
    let stats = DetectionStats {
        analysis_duration_ms: 1500,
        functions_analyzed: 10,
        instructions_analyzed: 500,
        rules_executed: 9,
        patterns_matched: 3,
    };

    assert_eq!(stats.analysis_duration_ms, 1500);
    assert_eq!(stats.functions_analyzed, 10);
    assert_eq!(stats.instructions_analyzed, 500);
    assert_eq!(stats.rules_executed, 9);
    assert_eq!(stats.patterns_matched, 3);
}

#[test]
fn test_vulnerability_rule_creation() {
    let rule = VulnerabilityRule {
        id: "TEST001".to_string(),
        name: "Test Rule".to_string(),
        severity: Severity::High,
        category: VulnerabilityCategory::BufferOverflow,
        description: "Test description".to_string(),
        cve_references: vec!["CVE-2021-1234".to_string()],
        cwe_references: vec!["CWE-120".to_string()],
        mitigation: "Test mitigation".to_string(),
        pattern: DetectionPattern::UnsafeFunction {
            function_names: vec!["strcpy".to_string()],
            context_checks: vec![ContextCheck::HasBoundsCheck],
        },
    };

    assert_eq!(rule.id, "TEST001");
    assert_eq!(rule.name, "Test Rule");
    assert!(matches!(rule.severity, Severity::High));
}

#[test]
fn test_instruction_matcher_variants() {
    let matchers = vec![
        InstructionMatcher::Mnemonic("mov".to_string()),
        InstructionMatcher::InstructionType(InstructionType::Memory),
        InstructionMatcher::FlowControl(FlowControl::Jump(0x1000)),
        InstructionMatcher::Register("eax".to_string()),
        InstructionMatcher::Immediate(0xFF),
        InstructionMatcher::AnyInstruction,
    ];

    assert_eq!(matchers.len(), 6);

    // Ensure all variants are covered
    for matcher in &matchers {
        match matcher {
            InstructionMatcher::Mnemonic(s) => assert!(!s.is_empty()),
            InstructionMatcher::InstructionType(_) => {}
            InstructionMatcher::FlowControl(_) => {}
            InstructionMatcher::Register(s) => assert!(!s.is_empty()),
            InstructionMatcher::Immediate(n) => assert!(*n > 0),
            InstructionMatcher::AnyInstruction => {}
        }
    }
}

#[test]
fn test_control_flow_pattern_types() {
    let patterns = vec![
        ControlFlowPatternType::DeepRecursion,
        ControlFlowPatternType::UncontrolledLoop,
        ControlFlowPatternType::ComplexConditions,
        ControlFlowPatternType::UnreachableCode,
        ControlFlowPatternType::MissingErrorHandling,
    ];

    assert_eq!(patterns.len(), 5);
}

#[test]
fn test_context_check_variants() {
    let checks = vec![
        ContextCheck::HasBoundsCheck,
        ContextCheck::HasNullCheck,
        ContextCheck::HasLengthValidation,
        ContextCheck::InLoopContext,
        ContextCheck::UserInputSource,
        ContextCheck::StackAllocation,
    ];

    assert_eq!(checks.len(), 6);
}

#[test]
fn test_memory_operation_variants() {
    let operations = vec![
        MemoryOperation::Allocation,
        MemoryOperation::Deallocation,
        MemoryOperation::Access,
        MemoryOperation::Copy,
        MemoryOperation::Move,
    ];

    assert_eq!(operations.len(), 5);
}

#[test]
fn test_combination_logic_variants() {
    let logic_types = vec![
        CombinationLogic::And,
        CombinationLogic::Or,
        CombinationLogic::Not,
        CombinationLogic::Sequence,
    ];

    assert_eq!(logic_types.len(), 4);
}

#[test]
fn test_detection_pattern_unsafe_function() {
    let pattern = DetectionPattern::UnsafeFunction {
        function_names: vec!["strcpy".to_string(), "gets".to_string()],
        context_checks: vec![ContextCheck::HasBoundsCheck],
    };

    match pattern {
        DetectionPattern::UnsafeFunction {
            function_names,
            context_checks,
        } => {
            assert_eq!(function_names.len(), 2);
            assert_eq!(context_checks.len(), 1);
            assert!(function_names.contains(&"strcpy".to_string()));
            assert!(function_names.contains(&"gets".to_string()));
        }
        _ => panic!("Expected UnsafeFunction pattern"),
    }
}

#[test]
fn test_detection_pattern_instruction_sequence() {
    let pattern = DetectionPattern::InstructionSequence {
        pattern: vec![
            InstructionMatcher::Mnemonic("sub".to_string()),
            InstructionMatcher::Register("rsp".to_string()),
        ],
        window_size: 2,
    };

    match pattern {
        DetectionPattern::InstructionSequence {
            pattern,
            window_size,
        } => {
            assert_eq!(pattern.len(), 2);
            assert_eq!(window_size, 2);
        }
        _ => panic!("Expected InstructionSequence pattern"),
    }
}

#[test]
fn test_detection_pattern_control_flow() {
    let pattern = DetectionPattern::ControlFlowPattern {
        pattern_type: ControlFlowPatternType::DeepRecursion,
        complexity_threshold: Some(10),
    };

    match pattern {
        DetectionPattern::ControlFlowPattern {
            pattern_type,
            complexity_threshold,
        } => {
            assert!(matches!(
                pattern_type,
                ControlFlowPatternType::DeepRecursion
            ));
            assert_eq!(complexity_threshold, Some(10));
        }
        _ => panic!("Expected ControlFlowPattern"),
    }
}

#[test]
fn test_detection_pattern_memory() {
    let pattern = DetectionPattern::MemoryPattern {
        operations: vec![MemoryOperation::Allocation, MemoryOperation::Deallocation],
        unsafe_operations: vec!["malloc".to_string(), "free".to_string()],
    };

    match pattern {
        DetectionPattern::MemoryPattern {
            operations,
            unsafe_operations,
        } => {
            assert_eq!(operations.len(), 2);
            assert_eq!(unsafe_operations.len(), 2);
        }
        _ => panic!("Expected MemoryPattern"),
    }
}

#[test]
fn test_detection_pattern_combined() {
    let pattern = DetectionPattern::Combined {
        patterns: vec![
            DetectionPattern::UnsafeFunction {
                function_names: vec!["strcpy".to_string()],
                context_checks: vec![],
            },
            DetectionPattern::InstructionSequence {
                pattern: vec![InstructionMatcher::AnyInstruction],
                window_size: 1,
            },
        ],
        logic: CombinationLogic::And,
    };

    match pattern {
        DetectionPattern::Combined { patterns, logic } => {
            assert_eq!(patterns.len(), 2);
            assert!(matches!(logic, CombinationLogic::And));
        }
        _ => panic!("Expected Combined pattern"),
    }
}

#[test]
fn test_analyze_empty_data() {
    let detector = VulnerabilityDetector::new();
    let symbol_table = create_symbol_table(vec![]);
    let cfg_analysis = create_cfg_analysis(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    assert_eq!(result.vulnerabilities.len(), 0);
    assert_eq!(result.risk_assessment.total_vulnerabilities, 0);
    assert_eq!(result.risk_assessment.overall_risk_score, 0.0);
    assert!(matches!(
        result.risk_assessment.risk_level,
        RiskLevel::Minimal
    ));
    assert_eq!(result.detection_stats.functions_analyzed, 0);
    assert!(result.detection_stats.analysis_duration_ms >= 0);
}

#[test]
fn test_analyze_dangerous_function_calls() {
    let detector = VulnerabilityDetector::new();

    // Create instructions with dangerous function calls
    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "strcpy@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
        create_instruction(
            0x1004,
            "call",
            "gets@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2004),
        ),
        create_instruction(
            0x1008,
            "call",
            "sprintf@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2008),
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("vulnerable_func", 0x1000, vec![basic_block], 5, 8);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Should detect at least one vulnerability for dangerous functions
    assert!(!result.vulnerabilities.is_empty());
    
    // Check that we found buffer overflow vulnerabilities
    let buffer_overflow_vulns: Vec<_> = result
        .vulnerabilities
        .iter()
        .filter(|v| matches!(v.category, VulnerabilityCategory::BufferOverflow))
        .collect();
    assert!(!buffer_overflow_vulns.is_empty());

    // Verify vulnerability properties
    for vuln in &result.vulnerabilities {
        assert!(!vuln.locations.is_empty());
        assert!(vuln.confidence > 0.5);
        assert!(!vuln.mitigation.is_empty());
    }

    assert!(result.risk_assessment.total_vulnerabilities > 0);
    assert!(result.risk_assessment.overall_risk_score > 0.0);
}

#[test]
fn test_analyze_format_string_vulnerabilities() {
    let detector = VulnerabilityDetector::new();

    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "printf@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
        create_instruction(
            0x1004,
            "call",
            "fprintf@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2004),
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("format_func", 0x1000, vec![basic_block], 3, 5);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Check for format string vulnerabilities
    let format_string_vulns: Vec<_> = result
        .vulnerabilities
        .iter()
        .filter(|v| matches!(v.category, VulnerabilityCategory::FormatString))
        .collect();
    assert!(!format_string_vulns.is_empty());
}

#[test]
fn test_analyze_division_by_zero() {
    let detector = VulnerabilityDetector::new();

    let instructions = vec![create_instruction(
        0x1000,
        "div",
        "eax",
        InstructionType::Arithmetic,
        FlowControl::Fall,
    )];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("div_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Check for division by zero vulnerabilities
    let div_zero_vulns: Vec<_> = result
        .vulnerabilities
        .iter()
        .filter(|v| matches!(v.category, VulnerabilityCategory::DivisionByZero))
        .collect();
    assert!(!div_zero_vulns.is_empty());
}

#[test]
fn test_analyze_high_complexity_recursion() {
    let detector = VulnerabilityDetector::new();

    let basic_block = create_basic_block(0, vec![]);
    let cfg = create_cfg("complex_recursive_func", 0x1000, vec![basic_block], 15, 20);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Check for uncontrolled recursion vulnerabilities
    let recursion_vulns: Vec<_> = result
        .vulnerabilities
        .iter()
        .filter(|v| matches!(v.category, VulnerabilityCategory::UncontrolledRecursion))
        .collect();
    assert!(!recursion_vulns.is_empty());
}

#[test]
fn test_analyze_multiple_loops() {
    let detector = VulnerabilityDetector::new();

    let basic_block = create_basic_block(0, vec![]);
    let mut cfg = create_cfg("loopy_func", 0x1000, vec![basic_block], 8, 12);
    
    // Add multiple loops
    cfg.loops = vec![
        Loop {
            header_block: 0,
            body_blocks: vec![1, 2],
            exit_blocks: vec![3],
            loop_type: LoopType::Natural,
            nesting_level: 1,
        },
        Loop {
            header_block: 4,
            body_blocks: vec![5, 6],
            exit_blocks: vec![7],
            loop_type: LoopType::Natural,
            nesting_level: 1,
        },
        Loop {
            header_block: 8,
            body_blocks: vec![9, 10],
            exit_blocks: vec![11],
            loop_type: LoopType::Natural,
            nesting_level: 1,
        },
        Loop {
            header_block: 12,
            body_blocks: vec![13, 14],
            exit_blocks: vec![15],
            loop_type: LoopType::Natural,
            nesting_level: 1,
        },
    ];

    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // The detector may or may not detect loop patterns based on implementation
    // Just verify that analysis completes successfully
    assert_eq!(result.detection_stats.functions_analyzed, 1);
}

#[test]
fn test_analyze_unreachable_code() {
    let detector = VulnerabilityDetector::new();

    let basic_block = create_basic_block(0, vec![]);
    let mut cfg = create_cfg("unreachable_func", 0x1000, vec![basic_block], 5, 8);
    
    // Add unreachable blocks
    cfg.complexity.unreachable_blocks = vec![2, 3, 5];

    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // The detector may or may not detect unreachable code based on implementation
    // Just verify that analysis completes successfully
    assert_eq!(result.detection_stats.functions_analyzed, 1);
}

#[test]
fn test_analyze_dangerous_imports() {
    let detector = VulnerabilityDetector::new();

    let imports = vec![
        ImportInfo {
            name: "strcpy".to_string(),
            address: Some(0x2000),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
        ImportInfo {
            name: "gets".to_string(),
            address: Some(0x2004),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
        ImportInfo {
            name: "safe_function".to_string(),
            address: Some(0x2008),
            library: Some("libsafe.so".to_string()),
            ordinal: None,
            is_delayed: false,
        },
    ];

    let symbol_table = create_symbol_table(imports);
    let cfg_analysis = create_cfg_analysis(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Should detect dangerous imports
    assert!(result.vulnerabilities.len() >= 2); // strcpy and gets
    
    for vuln in &result.vulnerabilities {
        assert_eq!(vuln.locations[0].function_name, "Imports");
        assert!(vuln.confidence >= 0.9);
        assert!(vuln.locations[0].instruction.contains("import"));
    }
}

#[test]
fn test_instruction_pattern_matching() {
    // Test instruction pattern matching through public API
    let detector = VulnerabilityDetector::new();

    // Create various instruction patterns that should trigger vulnerabilities
    let div_instructions = vec![create_instruction(
        0x1000,
        "div",
        "eax",
        InstructionType::Arithmetic,
        FlowControl::Fall,
    )];

    let basic_block = create_basic_block(0, div_instructions);
    let cfg = create_cfg("div_test_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Should detect division by zero vulnerability through pattern matching
    let div_vulns: Vec<_> = result
        .vulnerabilities
        .iter()
        .filter(|v| matches!(v.category, VulnerabilityCategory::DivisionByZero))
        .collect();
    assert!(!div_vulns.is_empty());
}

#[test]
fn test_dangerous_function_detection() {
    let detector = VulnerabilityDetector::new();

    // Test detection of dangerous functions through public API
    let imports = vec![
        ImportInfo {
            name: "strcpy".to_string(),
            address: Some(0x2000),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
        ImportInfo {
            name: "printf".to_string(),
            address: Some(0x2004),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
        ImportInfo {
            name: "free".to_string(),
            address: Some(0x2008),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
        ImportInfo {
            name: "safe_function".to_string(),
            address: Some(0x200C),
            library: Some("libsafe.so".to_string()),
            ordinal: None,
            is_delayed: false,
        },
    ];

    let symbol_table = create_symbol_table(imports);
    let cfg_analysis = create_cfg_analysis(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Should detect dangerous imports
    assert!(result.vulnerabilities.len() >= 3); // strcpy, printf, free
    
    // Verify dangerous functions are detected
    let func_names: Vec<_> = result.vulnerabilities.iter()
        .filter_map(|v| {
            if v.locations[0].instruction.contains("import") {
                Some(v.locations[0].instruction.clone())
            } else {
                None
            }
        })
        .collect();
    
    assert!(func_names.iter().any(|n| n.contains("strcpy")));
    assert!(func_names.iter().any(|n| n.contains("printf")));
    assert!(func_names.iter().any(|n| n.contains("free")));
    assert!(!func_names.iter().any(|n| n.contains("safe_function")));
}

#[test]
fn test_risk_assessment_empty() {
    let detector = VulnerabilityDetector::new();
    let symbol_table = create_symbol_table(vec![]);
    let cfg_analysis = create_cfg_analysis(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();
    let risk = &result.risk_assessment;

    assert_eq!(risk.overall_risk_score, 0.0);
    assert_eq!(risk.critical_count, 0);
    assert_eq!(risk.high_count, 0);
    assert_eq!(risk.medium_count, 0);
    assert_eq!(risk.low_count, 0);
    assert_eq!(risk.total_vulnerabilities, 0);
    assert!(matches!(risk.risk_level, RiskLevel::Minimal));
    assert_eq!(risk.recommendations.len(), 1);
    assert!(risk.recommendations[0].contains("No vulnerabilities detected"));
}

#[test]
fn test_risk_assessment_with_vulnerabilities() {
    let detector = VulnerabilityDetector::new();

    // Create a scenario with multiple vulnerability types to test risk assessment
    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "strcpy@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
        create_instruction(
            0x1004,
            "call",
            "gets@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2004),
        ),
        create_instruction(
            0x1008,
            "div",
            "eax",
            InstructionType::Arithmetic,
            FlowControl::Fall,
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("multi_vuln_func", 0x1000, vec![basic_block], 5, 8);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    
    // Add dangerous imports
    let imports = vec![
        ImportInfo {
            name: "strcpy".to_string(),
            address: Some(0x2000),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
    ];
    let symbol_table = create_symbol_table(imports);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();
    let risk = &result.risk_assessment;

    // Should have detected multiple vulnerabilities
    assert!(risk.total_vulnerabilities > 0);
    assert!(risk.overall_risk_score > 0.0);
    assert!(!matches!(risk.risk_level, RiskLevel::Minimal));
    assert!(!risk.recommendations.is_empty());
    
    // Should have appropriate recommendations based on severity
    if risk.critical_count > 0 {
        assert!(risk.recommendations.iter().any(|r| r.contains("Immediate")));
    }
    if risk.high_count > 0 {
        assert!(risk.recommendations.iter().any(|r| r.contains("24 hours")));
    }
}

#[test]
fn test_vulnerability_detection_result_serialization() {
    let result = VulnerabilityDetectionResult {
        vulnerabilities: vec![DetectedVulnerability {
            rule_id: "TEST001".to_string(),
            rule_name: "Test Rule".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::BufferOverflow,
            description: "Test vulnerability".to_string(),
            locations: vec![CodeLocation {
                function_name: "test_func".to_string(),
                function_address: 0x1000,
                instruction_address: 0x1004,
                basic_block_id: 0,
                instruction: "call strcpy".to_string(),
                source_line: Some(42),
            }],
            confidence: 0.85,
            context: "Test context".to_string(),
            cve_references: vec!["CVE-2021-1234".to_string()],
            cwe_references: vec!["CWE-120".to_string()],
            mitigation: "Use safe functions".to_string(),
        }],
        risk_assessment: RiskAssessment {
            overall_risk_score: 7.5,
            critical_count: 0,
            high_count: 1,
            medium_count: 0,
            low_count: 0,
            total_vulnerabilities: 1,
            risk_level: RiskLevel::High,
            recommendations: vec!["Address high severity issues".to_string()],
        },
        detection_stats: DetectionStats {
            analysis_duration_ms: 250,
            functions_analyzed: 5,
            instructions_analyzed: 100,
            rules_executed: 9,
            patterns_matched: 1,
        },
    };

    // Test JSON serialization/deserialization
    let json = serde_json::to_string(&result).unwrap();
    let deserialized: VulnerabilityDetectionResult = serde_json::from_str(&json).unwrap();

    assert_eq!(deserialized.vulnerabilities.len(), 1);
    assert_eq!(
        deserialized.vulnerabilities[0].rule_id,
        result.vulnerabilities[0].rule_id
    );
    assert_eq!(
        deserialized.risk_assessment.overall_risk_score,
        result.risk_assessment.overall_risk_score
    );
    assert_eq!(
        deserialized.detection_stats.functions_analyzed,
        result.detection_stats.functions_analyzed
    );
}

#[test]
fn test_edge_case_empty_instructions() {
    let detector = VulnerabilityDetector::new();

    // Test with empty instruction list in a basic block
    let empty_block = create_basic_block(0, vec![]);
    let cfg = create_cfg("empty_func", 0x1000, vec![empty_block], 1, 1);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();
    
    // Should handle empty functions gracefully
    assert_eq!(result.detection_stats.functions_analyzed, 1);
}

#[test]
fn test_edge_case_null_pointer_pattern() {
    let detector = VulnerabilityDetector::new();

    // Test null pointer dereference pattern with immediate 0
    let instructions = vec![
        create_instruction(
            0x1000,
            "mov",
            "eax, 0",
            InstructionType::Memory,
            FlowControl::Fall,
        ),
        create_instruction(
            0x1004,
            "mov",
            "[eax], ebx",
            InstructionType::Memory,
            FlowControl::Fall,
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("null_deref_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Should detect potential null pointer dereference
    let null_ptr_vulns: Vec<_> = result
        .vulnerabilities
        .iter()
        .filter(|v| matches!(v.category, VulnerabilityCategory::NullPointerDereference))
        .collect();
    assert!(!null_ptr_vulns.is_empty());
}

#[test]
fn test_edge_case_stack_allocation_pattern() {
    let detector = VulnerabilityDetector::new();

    // Test large stack buffer allocation pattern
    let instructions = vec![
        create_instruction(
            0x1000,
            "sub",
            "rsp, 0x10000", // Large stack allocation
            InstructionType::Arithmetic,
            FlowControl::Fall,
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("stack_alloc_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Stack allocation pattern may or may not be detected
    // Just verify that analysis completes successfully
    assert_eq!(result.detection_stats.functions_analyzed, 1);
    assert!(result.detection_stats.rules_executed > 0);
}

#[test]
fn test_analyze_vulnerabilities_function() {
    use std::path::Path;

    let path = Path::new("/test/binary");
    let symbol_table = create_symbol_table(vec![]);
    let cfg_analysis = create_cfg_analysis(vec![]);

    let result = analyze_vulnerabilities(path, &symbol_table, &cfg_analysis);
    assert!(result.is_ok());

    let result = result.unwrap();
    assert_eq!(result.vulnerabilities.len(), 0);
    assert!(matches!(result.risk_assessment.risk_level, RiskLevel::Minimal));
}

#[test]
fn test_complex_control_flow_integration() {
    let detector = VulnerabilityDetector::new();

    // Create a complex function with multiple vulnerability types
    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "strcpy@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
        create_instruction(
            0x1004,
            "div",
            "ecx",
            InstructionType::Arithmetic,
            FlowControl::Fall,
        ),
        create_instruction(
            0x1008,
            "call",
            "free@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2004),
        ),
        create_instruction(
            0x100C,
            "mov",
            "[eax], ebx", // Use after free
            InstructionType::Memory,
            FlowControl::Fall,
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let mut cfg = create_cfg("complex_vulnerable_func", 0x1000, vec![basic_block], 12, 18);
    
    // Mark as having high complexity
    cfg.complexity.cognitive_complexity = 25;
    
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    
    // Add dangerous imports
    let imports = vec![
        ImportInfo {
            name: "strcpy".to_string(),
            address: Some(0x2000),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
        ImportInfo {
            name: "free".to_string(),
            address: Some(0x2004),
            library: Some("libc.so.6".to_string()),
            ordinal: None,
            is_delayed: false,
        },
    ];
    let symbol_table = create_symbol_table(imports);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Should detect multiple vulnerability types
    assert!(result.vulnerabilities.len() >= 3);
    
    // Should have a non-zero risk score due to vulnerabilities
    assert!(result.risk_assessment.overall_risk_score > 0.0);
    assert!(!matches!(
        result.risk_assessment.risk_level,
        RiskLevel::Minimal
    ));
    
    // Should have multiple recommendations
    assert!(!result.risk_assessment.recommendations.is_empty());
    
    // Detection stats should be populated
    assert_eq!(result.detection_stats.functions_analyzed, 1);
    assert!(result.detection_stats.rules_executed > 0);
    assert!(result.detection_stats.patterns_matched > 0);
}

#[test]
fn test_confidence_levels() {
    let detector = VulnerabilityDetector::new();

    // Test that different detection methods produce appropriate confidence levels
    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "strcpy@PLT", // Direct call - high confidence
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("test_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);
    
    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    for vuln in &result.vulnerabilities {
        // Vulnerabilities should have reasonable confidence levels
        assert!(vuln.confidence > 0.0 && vuln.confidence <= 1.0);
        
        // Import-based detections typically have high confidence
        if vuln.locations[0].function_name == "Imports" {
            assert!(vuln.confidence >= 0.8);
        }
    }
}

#[test]
fn test_cve_cwe_references() {
    let detector = VulnerabilityDetector::new();

    // Test that vulnerabilities include proper CVE/CWE references
    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "strcpy@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("test_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Check that detected vulnerabilities have CVE/CWE references
    for vuln in &result.vulnerabilities {
        // Buffer overflow vulnerabilities should have CWE references
        if matches!(vuln.category, VulnerabilityCategory::BufferOverflow) {
            assert!(!vuln.cwe_references.is_empty());
            // Should contain relevant CWE IDs
            assert!(vuln.cwe_references.iter().any(|cwe| 
                cwe == "CWE-120" || cwe == "CWE-121"
            ));
        }
        
        // Format string vulnerabilities should have references
        if matches!(vuln.category, VulnerabilityCategory::FormatString) {
            assert!(!vuln.cwe_references.is_empty());
            assert!(vuln.cwe_references.contains(&"CWE-134".to_string()));
        }
    }
}

#[test]
fn test_mitigation_recommendations() {
    let detector = VulnerabilityDetector::new();

    // Test that detected vulnerabilities include mitigation recommendations
    let instructions = vec![
        create_instruction(
            0x1000,
            "call",
            "strcpy@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2000),
        ),
        create_instruction(
            0x1004,
            "call",
            "printf@PLT",
            InstructionType::Call,
            FlowControl::Call(0x2004),
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("test_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // All vulnerabilities should have mitigation recommendations
    for vuln in &result.vulnerabilities {
        assert!(!vuln.mitigation.is_empty());
        
        // Check specific mitigations
        // Check for reasonable mitigation content
        if vuln.locations[0].instruction.contains("strcpy") ||
           vuln.description.contains("strcpy") ||
           vuln.context.contains("strcpy") {
            // Mitigation should mention safer alternatives
            assert!(!vuln.mitigation.is_empty());
        }
        
        if vuln.locations[0].instruction.contains("printf") {
            assert!(vuln.mitigation.contains("format") || vuln.mitigation.contains("specifier"));
        }
    }
}

#[test] 
fn test_instruction_sequence_window_sliding() {
    let detector = VulnerabilityDetector::new();

    // Create a sequence of instructions where pattern appears in the middle
    let instructions = vec![
        create_instruction(
            0x1000,
            "push",
            "ebp",
            InstructionType::Memory,
            FlowControl::Fall,
        ),
        create_instruction(
            0x1004,
            "mov",
            "ebp, esp",
            InstructionType::Memory,
            FlowControl::Fall,
        ),
        create_instruction(
            0x1008,
            "sub",
            "rsp, 0x1000", // Pattern starts here
            InstructionType::Arithmetic,
            FlowControl::Fall,
        ),
        create_instruction(
            0x100C,
            "mov",
            "eax, 0",
            InstructionType::Memory,
            FlowControl::Fall,
        ),
    ];

    let basic_block = create_basic_block(0, instructions);
    let cfg = create_cfg("window_test_func", 0x1000, vec![basic_block], 2, 3);
    let cfg_analysis = create_cfg_analysis(vec![cfg]);
    let symbol_table = create_symbol_table(vec![]);

    let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

    // Stack allocation pattern may or may not be detected by BOF002
    // Just verify that analysis completes and patterns were checked
    assert_eq!(result.detection_stats.functions_analyzed, 1);
    assert!(result.detection_stats.rules_executed > 0);
}