use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::path::Path;

use crate::control_flow::{
    ControlFlowAnalysis, ControlFlowGraph, FlowControl, Instruction, InstructionType,
};
use crate::function_analysis::SymbolTable;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct VulnerabilityDetectionResult {
    pub vulnerabilities: Vec<DetectedVulnerability>,
    pub risk_assessment: RiskAssessment,
    pub detection_stats: DetectionStats,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DetectedVulnerability {
    pub rule_id: String,
    pub rule_name: String,
    pub severity: Severity,
    pub category: VulnerabilityCategory,
    pub description: String,
    pub locations: Vec<CodeLocation>,
    pub confidence: f32,
    pub context: String,
    pub cve_references: Vec<String>,
    pub cwe_references: Vec<String>,
    pub mitigation: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CodeLocation {
    pub function_name: String,
    pub function_address: u64,
    pub instruction_address: u64,
    pub basic_block_id: usize,
    pub instruction: String,
    pub source_line: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum VulnerabilityCategory {
    BufferOverflow,
    FormatString,
    IntegerOverflow,
    UseAfterFree,
    NullPointerDereference,
    RaceCondition,
    InjectionVulnerability,
    CryptographicWeakness,
    MemoryLeak,
    DoubleFree,
    UncontrolledRecursion,
    DivisionByZero,
    SignedIntegerOverflow,
    UnsafeAPIUsage,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RiskAssessment {
    pub overall_risk_score: f32, // 0.0 to 10.0
    pub critical_count: u32,
    pub high_count: u32,
    pub medium_count: u32,
    pub low_count: u32,
    pub total_vulnerabilities: u32,
    pub risk_level: RiskLevel,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum RiskLevel {
    Critical,
    High,
    Medium,
    Low,
    Minimal,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DetectionStats {
    pub analysis_duration_ms: u64,
    pub functions_analyzed: usize,
    pub instructions_analyzed: usize,
    pub rules_executed: usize,
    pub patterns_matched: usize,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityRule {
    pub id: String,
    pub name: String,
    pub severity: Severity,
    pub category: VulnerabilityCategory,
    pub description: String,
    pub cve_references: Vec<String>,
    pub cwe_references: Vec<String>,
    pub mitigation: String,
    pub pattern: DetectionPattern,
}

#[derive(Debug, Clone)]
pub enum DetectionPattern {
    // Dangerous function calls
    UnsafeFunction {
        function_names: Vec<String>,
        context_checks: Vec<ContextCheck>,
    },

    // Instruction sequence patterns
    InstructionSequence {
        pattern: Vec<InstructionMatcher>,
        window_size: usize,
    },

    // Control flow patterns
    ControlFlowPattern {
        pattern_type: ControlFlowPatternType,
        complexity_threshold: Option<u32>,
    },

    // Memory operation patterns
    MemoryPattern {
        operations: Vec<MemoryOperation>,
        unsafe_operations: Vec<String>,
    },

    // Combined patterns
    Combined {
        patterns: Vec<DetectionPattern>,
        logic: CombinationLogic,
    },
}

#[derive(Debug, Clone)]
pub enum ContextCheck {
    HasBoundsCheck,
    HasNullCheck,
    HasLengthValidation,
    InLoopContext,
    UserInputSource,
    StackAllocation,
}

#[derive(Debug, Clone)]
pub enum InstructionMatcher {
    Mnemonic(String),
    InstructionType(InstructionType),
    FlowControl(FlowControl),
    Register(String),
    Immediate(u64),
    AnyInstruction,
}

#[derive(Debug, Clone)]
pub enum ControlFlowPatternType {
    DeepRecursion,
    UncontrolledLoop,
    ComplexConditions,
    UnreachableCode,
    MissingErrorHandling,
}

#[derive(Debug, Clone)]
pub enum MemoryOperation {
    Allocation,
    Deallocation,
    Access,
    Copy,
    Move,
}

#[derive(Debug, Clone)]
pub enum CombinationLogic {
    And,
    Or,
    Not,
    Sequence,
}

pub struct VulnerabilityDetector {
    rules: Vec<VulnerabilityRule>,
    dangerous_functions: HashSet<String>,
}

impl VulnerabilityDetector {
    pub fn new() -> Self {
        let mut detector = Self {
            rules: Vec::new(),
            dangerous_functions: HashSet::new(),
        };

        detector.load_default_rules();
        detector
    }

    fn load_default_rules(&mut self) {
        // Buffer Overflow Rules
        self.add_rule(VulnerabilityRule {
            id: "BOF001".to_string(),
            name: "Dangerous String Functions".to_string(),
            severity: Severity::Critical,
            category: VulnerabilityCategory::BufferOverflow,
            description: "Use of dangerous string functions that can cause buffer overflows"
                .to_string(),
            cve_references: vec!["CVE-2021-44228".to_string(), "CVE-2020-1472".to_string()],
            cwe_references: vec!["CWE-120".to_string(), "CWE-121".to_string()],
            mitigation:
                "Replace with safe alternatives: strcpy->strncpy, strcat->strncat, gets->fgets"
                    .to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec![
                    "strcpy".to_string(),
                    "strcat".to_string(),
                    "gets".to_string(),
                    "sprintf".to_string(),
                    "vsprintf".to_string(),
                ],
                context_checks: vec![ContextCheck::HasBoundsCheck],
            },
        });

        self.add_rule(VulnerabilityRule {
            id: "BOF002".to_string(),
            name: "Stack Buffer Allocation".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::BufferOverflow,
            description: "Large stack buffer allocation without bounds checking".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-121".to_string()],
            mitigation: "Use heap allocation or implement proper bounds checking".to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![
                    InstructionMatcher::Mnemonic("sub".to_string()),
                    InstructionMatcher::Register("rsp".to_string()),
                ],
                window_size: 2,
            },
        });

        // Format String Vulnerabilities
        self.add_rule(VulnerabilityRule {
            id: "FMT001".to_string(),
            name: "Format String Vulnerability".to_string(),
            severity: Severity::Critical,
            category: VulnerabilityCategory::FormatString,
            description: "User-controlled format string in printf family functions".to_string(),
            cve_references: vec!["CVE-2000-0573".to_string()],
            cwe_references: vec!["CWE-134".to_string()],
            mitigation: "Always use format specifiers like printf(\"%s\", user_input)".to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec![
                    "printf".to_string(),
                    "fprintf".to_string(),
                    "sprintf".to_string(),
                    "snprintf".to_string(),
                    "vprintf".to_string(),
                    "vfprintf".to_string(),
                    "vsprintf".to_string(),
                    "vsnprintf".to_string(),
                ],
                context_checks: vec![ContextCheck::UserInputSource],
            },
        });

        // Integer Overflow
        self.add_rule(VulnerabilityRule {
            id: "INT001".to_string(),
            name: "Integer Overflow in Arithmetic".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::IntegerOverflow,
            description: "Arithmetic operations that may cause integer overflow".to_string(),
            cve_references: vec!["CVE-2021-3156".to_string()],
            cwe_references: vec!["CWE-190".to_string()],
            mitigation: "Use safe arithmetic functions or check for overflow before operations"
                .to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![
                    InstructionMatcher::InstructionType(InstructionType::Arithmetic),
                    InstructionMatcher::InstructionType(InstructionType::Memory),
                ],
                window_size: 3,
            },
        });

        // Use After Free
        self.add_rule(VulnerabilityRule {
            id: "UAF001".to_string(),
            name: "Potential Use After Free".to_string(),
            severity: Severity::Critical,
            category: VulnerabilityCategory::UseAfterFree,
            description: "Memory access after free operation".to_string(),
            cve_references: vec!["CVE-2021-22555".to_string()],
            cwe_references: vec!["CWE-416".to_string()],
            mitigation: "Set pointers to NULL after free and check before use".to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec!["free".to_string(), "delete".to_string()],
                context_checks: vec![ContextCheck::HasNullCheck],
            },
        });

        // Double Free
        self.add_rule(VulnerabilityRule {
            id: "DBF001".to_string(),
            name: "Double Free Vulnerability".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::DoubleFree,
            description: "Multiple free operations on the same memory".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-415".to_string()],
            mitigation: "Set pointers to NULL after free and check before subsequent free"
                .to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec!["free".to_string(), "delete".to_string()],
                context_checks: vec![],
            },
        });

        // Null Pointer Dereference
        self.add_rule(VulnerabilityRule {
            id: "NPD001".to_string(),
            name: "Null Pointer Dereference".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::NullPointerDereference,
            description: "Potential null pointer dereference".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-476".to_string()],
            mitigation: "Always check pointers for NULL before dereferencing".to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![
                    InstructionMatcher::InstructionType(InstructionType::Memory),
                    InstructionMatcher::Immediate(0),
                ],
                window_size: 2,
            },
        });

        // Division by Zero
        self.add_rule(VulnerabilityRule {
            id: "DIV001".to_string(),
            name: "Division by Zero".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::DivisionByZero,
            description: "Division operation without zero check".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-369".to_string()],
            mitigation: "Check divisor for zero before division operations".to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![InstructionMatcher::Mnemonic("div".to_string())],
                window_size: 1,
            },
        });

        // Uncontrolled Recursion
        self.add_rule(VulnerabilityRule {
            id: "REC001".to_string(),
            name: "Uncontrolled Recursion".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::UncontrolledRecursion,
            description: "Function with high cyclomatic complexity indicating potential uncontrolled recursion".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-674".to_string()],
            mitigation: "Implement recursion depth limits and iterative alternatives".to_string(),
            pattern: DetectionPattern::ControlFlowPattern {
                pattern_type: ControlFlowPatternType::DeepRecursion,
                complexity_threshold: Some(10),
            },
        });

        // Populate dangerous functions set
        for rule in &self.rules {
            if let DetectionPattern::UnsafeFunction { function_names, .. } = &rule.pattern {
                for func_name in function_names {
                    self.dangerous_functions.insert(func_name.clone());
                }
            }
        }
    }

    fn add_rule(&mut self, rule: VulnerabilityRule) {
        self.rules.push(rule);
    }

    pub fn analyze(
        &self,
        symbol_table: &SymbolTable,
        cfg_analysis: &ControlFlowAnalysis,
    ) -> Result<VulnerabilityDetectionResult> {
        let start_time = std::time::Instant::now();
        let mut vulnerabilities = Vec::new();
        let mut patterns_matched = 0;

        // Analyze each function's CFG for vulnerabilities
        for cfg in &cfg_analysis.cfgs {
            let function_vulns = self.analyze_function(cfg, symbol_table)?;
            patterns_matched += function_vulns.len();
            vulnerabilities.extend(function_vulns);
        }

        // Analyze symbol table for dangerous imports
        let import_vulns = self.analyze_imports(symbol_table)?;
        vulnerabilities.extend(import_vulns);

        // Calculate risk assessment
        let risk_assessment = self.calculate_risk_assessment(&vulnerabilities);

        let duration = start_time.elapsed().as_millis() as u64;

        Ok(VulnerabilityDetectionResult {
            vulnerabilities,
            risk_assessment,
            detection_stats: DetectionStats {
                analysis_duration_ms: duration,
                functions_analyzed: cfg_analysis.cfgs.len(),
                instructions_analyzed: cfg_analysis.analysis_stats.instructions_analyzed,
                rules_executed: self.rules.len(),
                patterns_matched,
            },
        })
    }

    fn analyze_function(
        &self,
        cfg: &ControlFlowGraph,
        _symbol_table: &SymbolTable,
    ) -> Result<Vec<DetectedVulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Check each rule against this function
        for rule in &self.rules {
            match &rule.pattern {
                DetectionPattern::UnsafeFunction {
                    function_names,
                    context_checks,
                } => {
                    if let Some(vuln) =
                        self.check_unsafe_function_calls(cfg, rule, function_names, context_checks)?
                    {
                        vulnerabilities.push(vuln);
                    }
                }
                DetectionPattern::InstructionSequence {
                    pattern,
                    window_size,
                } => {
                    if let Some(vuln) =
                        self.check_instruction_sequence(cfg, rule, pattern, *window_size)?
                    {
                        vulnerabilities.push(vuln);
                    }
                }
                DetectionPattern::ControlFlowPattern {
                    pattern_type,
                    complexity_threshold,
                } => {
                    if let Some(vuln) = self.check_control_flow_pattern(
                        cfg,
                        rule,
                        pattern_type,
                        *complexity_threshold,
                    )? {
                        vulnerabilities.push(vuln);
                    }
                }
                _ => {
                    // TODO: Implement other pattern types
                }
            }
        }

        Ok(vulnerabilities)
    }

    fn check_unsafe_function_calls(
        &self,
        cfg: &ControlFlowGraph,
        rule: &VulnerabilityRule,
        function_names: &[String],
        _context_checks: &[ContextCheck],
    ) -> Result<Option<DetectedVulnerability>> {
        let mut locations = Vec::new();

        // Check all instructions in all basic blocks
        for basic_block in &cfg.basic_blocks {
            for instruction in &basic_block.instructions {
                // Check if instruction is a call to a dangerous function
                if matches!(instruction.instruction_type, InstructionType::Call) {
                    if let FlowControl::Call(_) = instruction.flow_control {
                        // Parse the operand to extract function name
                        let operand = &instruction.operands;
                        for func_name in function_names {
                            if operand.contains(func_name) || instruction.mnemonic.contains("call")
                            {
                                locations.push(CodeLocation {
                                    function_name: cfg.function_name.clone(),
                                    function_address: cfg.function_address,
                                    instruction_address: instruction.address,
                                    basic_block_id: basic_block.id,
                                    instruction: format!(
                                        "{} {}",
                                        instruction.mnemonic, instruction.operands
                                    ),
                                    source_line: None,
                                });
                                break;
                            }
                        }
                    }
                }
            }
        }

        if !locations.is_empty() {
            Ok(Some(DetectedVulnerability {
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                severity: rule.severity.clone(),
                category: rule.category.clone(),
                description: rule.description.clone(),
                locations,
                confidence: 0.8, // High confidence for direct function calls
                context: format!(
                    "Function {} contains calls to dangerous functions",
                    cfg.function_name
                ),
                cve_references: rule.cve_references.clone(),
                cwe_references: rule.cwe_references.clone(),
                mitigation: rule.mitigation.clone(),
            }))
        } else {
            Ok(None)
        }
    }

    fn check_instruction_sequence(
        &self,
        cfg: &ControlFlowGraph,
        rule: &VulnerabilityRule,
        pattern: &[InstructionMatcher],
        window_size: usize,
    ) -> Result<Option<DetectedVulnerability>> {
        let mut locations = Vec::new();

        // Check instruction sequences in each basic block
        for basic_block in &cfg.basic_blocks {
            let instructions = &basic_block.instructions;

            for window_start in 0..instructions.len().saturating_sub(window_size - 1) {
                let window = &instructions
                    [window_start..std::cmp::min(window_start + window_size, instructions.len())];

                if self.matches_instruction_pattern(window, pattern) {
                    if let Some(first_instruction) = window.first() {
                        locations.push(CodeLocation {
                            function_name: cfg.function_name.clone(),
                            function_address: cfg.function_address,
                            instruction_address: first_instruction.address,
                            basic_block_id: basic_block.id,
                            instruction: format!(
                                "{} {}",
                                first_instruction.mnemonic, first_instruction.operands
                            ),
                            source_line: None,
                        });
                    }
                }
            }
        }

        if !locations.is_empty() {
            Ok(Some(DetectedVulnerability {
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                severity: rule.severity.clone(),
                category: rule.category.clone(),
                description: rule.description.clone(),
                locations,
                confidence: 0.6, // Medium confidence for instruction patterns
                context: format!(
                    "Function {} contains suspicious instruction patterns",
                    cfg.function_name
                ),
                cve_references: rule.cve_references.clone(),
                cwe_references: rule.cwe_references.clone(),
                mitigation: rule.mitigation.clone(),
            }))
        } else {
            Ok(None)
        }
    }

    fn check_control_flow_pattern(
        &self,
        cfg: &ControlFlowGraph,
        rule: &VulnerabilityRule,
        pattern_type: &ControlFlowPatternType,
        complexity_threshold: Option<u32>,
    ) -> Result<Option<DetectedVulnerability>> {
        let mut detected = false;
        let mut context = String::new();

        match pattern_type {
            ControlFlowPatternType::DeepRecursion => {
                if let Some(threshold) = complexity_threshold {
                    if cfg.complexity.cyclomatic_complexity > threshold {
                        detected = true;
                        context = format!(
                            "Function {} has high cyclomatic complexity ({}), indicating potential recursion issues",
                            cfg.function_name, cfg.complexity.cyclomatic_complexity
                        );
                    }
                }
            }
            ControlFlowPatternType::UncontrolledLoop => {
                if cfg.loops.len() > 3 {
                    detected = true;
                    context = format!(
                        "Function {} contains {} loops, potentially indicating uncontrolled iteration",
                        cfg.function_name, cfg.loops.len()
                    );
                }
            }
            ControlFlowPatternType::ComplexConditions => {
                if cfg.complexity.cognitive_complexity > 15 {
                    detected = true;
                    context = format!(
                        "Function {} has high cognitive complexity ({}), making it error-prone",
                        cfg.function_name, cfg.complexity.cognitive_complexity
                    );
                }
            }
            ControlFlowPatternType::UnreachableCode => {
                if !cfg.complexity.unreachable_blocks.is_empty() {
                    detected = true;
                    context = format!(
                        "Function {} contains {} unreachable basic blocks",
                        cfg.function_name,
                        cfg.complexity.unreachable_blocks.len()
                    );
                }
            }
            _ => {}
        }

        if detected {
            Ok(Some(DetectedVulnerability {
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                severity: rule.severity.clone(),
                category: rule.category.clone(),
                description: rule.description.clone(),
                locations: vec![CodeLocation {
                    function_name: cfg.function_name.clone(),
                    function_address: cfg.function_address,
                    instruction_address: cfg.function_address,
                    basic_block_id: 0,
                    instruction: "Function-level analysis".to_string(),
                    source_line: None,
                }],
                confidence: 0.5, // Lower confidence for heuristic-based detection
                context,
                cve_references: rule.cve_references.clone(),
                cwe_references: rule.cwe_references.clone(),
                mitigation: rule.mitigation.clone(),
            }))
        } else {
            Ok(None)
        }
    }

    fn matches_instruction_pattern(
        &self,
        instructions: &[Instruction],
        pattern: &[InstructionMatcher],
    ) -> bool {
        if instructions.len() < pattern.len() {
            return false;
        }

        for (i, matcher) in pattern.iter().enumerate() {
            if i >= instructions.len() {
                return false;
            }

            let instruction = &instructions[i];
            match matcher {
                InstructionMatcher::Mnemonic(mnemonic) => {
                    if instruction.mnemonic != *mnemonic {
                        return false;
                    }
                }
                InstructionMatcher::InstructionType(inst_type) => {
                    if std::mem::discriminant(&instruction.instruction_type)
                        != std::mem::discriminant(inst_type)
                    {
                        return false;
                    }
                }
                InstructionMatcher::Register(reg) => {
                    if !instruction.operands.contains(reg) {
                        return false;
                    }
                }
                InstructionMatcher::AnyInstruction => {
                    // Always matches
                }
                _ => {
                    // TODO: Implement other matchers
                }
            }
        }

        true
    }

    fn analyze_imports(&self, symbol_table: &SymbolTable) -> Result<Vec<DetectedVulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Check for dangerous imported functions
        for import in &symbol_table.imports {
            if self.dangerous_functions.contains(&import.name) {
                // Find the corresponding rule
                if let Some(rule) = self.find_rule_for_function(&import.name) {
                    vulnerabilities.push(DetectedVulnerability {
                        rule_id: rule.id.clone(),
                        rule_name: rule.name.clone(),
                        severity: rule.severity.clone(),
                        category: rule.category.clone(),
                        description: format!("Import of dangerous function: {}", import.name),
                        locations: vec![CodeLocation {
                            function_name: "Imports".to_string(),
                            function_address: 0,
                            instruction_address: 0,
                            basic_block_id: 0,
                            instruction: format!("import {}", import.name),
                            source_line: None,
                        }],
                        confidence: 0.9,
                        context: format!("Binary imports dangerous function {}", import.name),
                        cve_references: rule.cve_references.clone(),
                        cwe_references: rule.cwe_references.clone(),
                        mitigation: rule.mitigation.clone(),
                    });
                }
            }
        }

        Ok(vulnerabilities)
    }

    fn find_rule_for_function(&self, function_name: &str) -> Option<&VulnerabilityRule> {
        self.rules.iter().find(|rule| {
            if let DetectionPattern::UnsafeFunction { function_names, .. } = &rule.pattern {
                function_names.contains(&function_name.to_string())
            } else {
                false
            }
        })
    }

    fn calculate_risk_assessment(
        &self,
        vulnerabilities: &[DetectedVulnerability],
    ) -> RiskAssessment {
        let mut critical_count = 0;
        let mut high_count = 0;
        let mut medium_count = 0;
        let mut low_count = 0;

        let mut total_score = 0.0;

        for vuln in vulnerabilities {
            let severity_score = match vuln.severity {
                Severity::Critical => {
                    critical_count += 1;
                    10.0
                }
                Severity::High => {
                    high_count += 1;
                    7.5
                }
                Severity::Medium => {
                    medium_count += 1;
                    5.0
                }
                Severity::Low => {
                    low_count += 1;
                    2.5
                }
                Severity::Info => 1.0,
            };

            total_score += severity_score * vuln.confidence;
        }

        let overall_risk_score = if vulnerabilities.is_empty() {
            0.0
        } else {
            (total_score / vulnerabilities.len() as f32).min(10.0)
        };

        let risk_level = match overall_risk_score {
            score if score >= 8.0 => RiskLevel::Critical,
            score if score >= 6.0 => RiskLevel::High,
            score if score >= 4.0 => RiskLevel::Medium,
            score if score >= 2.0 => RiskLevel::Low,
            _ => RiskLevel::Minimal,
        };

        let mut recommendations = Vec::new();
        if critical_count > 0 {
            recommendations
                .push("Immediate remediation required for critical vulnerabilities".to_string());
        }
        if high_count > 0 {
            recommendations
                .push("Address high severity vulnerabilities within 24 hours".to_string());
        }
        if medium_count > 0 {
            recommendations.push("Plan remediation for medium severity issues".to_string());
        }
        if vulnerabilities.is_empty() {
            recommendations.push("No vulnerabilities detected in static analysis".to_string());
        }

        RiskAssessment {
            overall_risk_score,
            critical_count,
            high_count,
            medium_count,
            low_count,
            total_vulnerabilities: vulnerabilities.len() as u32,
            risk_level,
            recommendations,
        }
    }
}

pub fn analyze_vulnerabilities(
    _path: &Path,
    symbol_table: &SymbolTable,
    cfg_analysis: &ControlFlowAnalysis,
) -> Result<VulnerabilityDetectionResult> {
    let detector = VulnerabilityDetector::new();
    detector.analyze(symbol_table, cfg_analysis)
}
