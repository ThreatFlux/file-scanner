#![allow(dead_code)]
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::path::Path;

use crate::control_flow::{
    ControlFlowAnalysis, ControlFlowGraph, FlowControl, Instruction, InstructionType,
};
use crate::function_analysis::SymbolTable;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct VulnerabilityDetectionResult {
    pub vulnerabilities: Vec<DetectedVulnerability>,
    pub risk_assessment: RiskAssessment,
    pub detection_stats: DetectionStats,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DetectedVulnerability {
    pub rule_id: String,
    pub rule_name: String,
    pub severity: Severity,
    pub category: VulnerabilityCategory,
    pub description: String,
    pub locations: Vec<CodeLocation>,
    pub confidence: f32,
    pub context: String,
    pub cve_references: Vec<String>,
    pub cwe_references: Vec<String>,
    pub mitigation: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CodeLocation {
    pub function_name: String,
    pub function_address: u64,
    pub instruction_address: u64,
    pub basic_block_id: usize,
    pub instruction: String,
    pub source_line: Option<u32>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum VulnerabilityCategory {
    BufferOverflow,
    FormatString,
    IntegerOverflow,
    UseAfterFree,
    NullPointerDereference,
    RaceCondition,
    InjectionVulnerability,
    CryptographicWeakness,
    MemoryLeak,
    DoubleFree,
    UncontrolledRecursion,
    DivisionByZero,
    SignedIntegerOverflow,
    UnsafeAPIUsage,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RiskAssessment {
    pub overall_risk_score: f32, // 0.0 to 10.0
    pub critical_count: u32,
    pub high_count: u32,
    pub medium_count: u32,
    pub low_count: u32,
    pub total_vulnerabilities: u32,
    pub risk_level: RiskLevel,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum RiskLevel {
    Critical,
    High,
    Medium,
    Low,
    Minimal,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DetectionStats {
    pub analysis_duration_ms: u64,
    pub functions_analyzed: usize,
    pub instructions_analyzed: usize,
    pub rules_executed: usize,
    pub patterns_matched: usize,
}

#[derive(Debug, Clone)]
pub struct VulnerabilityRule {
    pub id: String,
    pub name: String,
    pub severity: Severity,
    pub category: VulnerabilityCategory,
    pub description: String,
    pub cve_references: Vec<String>,
    pub cwe_references: Vec<String>,
    pub mitigation: String,
    pub pattern: DetectionPattern,
}

#[derive(Debug, Clone)]
pub enum DetectionPattern {
    // Dangerous function calls
    UnsafeFunction {
        function_names: Vec<String>,
        context_checks: Vec<ContextCheck>,
    },

    // Instruction sequence patterns
    InstructionSequence {
        pattern: Vec<InstructionMatcher>,
        window_size: usize,
    },

    // Control flow patterns
    ControlFlowPattern {
        pattern_type: ControlFlowPatternType,
        complexity_threshold: Option<u32>,
    },

    // Memory operation patterns
    MemoryPattern {
        operations: Vec<MemoryOperation>,
        unsafe_operations: Vec<String>,
    },

    // Combined patterns
    Combined {
        patterns: Vec<DetectionPattern>,
        logic: CombinationLogic,
    },
}

#[derive(Debug, Clone)]
pub enum ContextCheck {
    HasBoundsCheck,
    HasNullCheck,
    HasLengthValidation,
    InLoopContext,
    UserInputSource,
    StackAllocation,
}

#[derive(Debug, Clone)]
pub enum InstructionMatcher {
    Mnemonic(String),
    InstructionType(InstructionType),
    FlowControl(FlowControl),
    Register(String),
    Immediate(u64),
    AnyInstruction,
}

#[derive(Debug, Clone)]
pub enum ControlFlowPatternType {
    DeepRecursion,
    UncontrolledLoop,
    ComplexConditions,
    UnreachableCode,
    MissingErrorHandling,
}

#[derive(Debug, Clone)]
pub enum MemoryOperation {
    Allocation,
    Deallocation,
    Access,
    Copy,
    Move,
}

#[derive(Debug, Clone)]
pub enum CombinationLogic {
    And,
    Or,
    Not,
    Sequence,
}

pub struct VulnerabilityDetector {
    rules: Vec<VulnerabilityRule>,
    dangerous_functions: HashSet<String>,
}

impl VulnerabilityDetector {
    pub fn new() -> Self {
        let mut detector = Self {
            rules: Vec::new(),
            dangerous_functions: HashSet::new(),
        };

        detector.load_default_rules();
        detector
    }

    fn load_default_rules(&mut self) {
        // Buffer Overflow Rules
        self.add_rule(VulnerabilityRule {
            id: "BOF001".to_string(),
            name: "Dangerous String Functions".to_string(),
            severity: Severity::Critical,
            category: VulnerabilityCategory::BufferOverflow,
            description: "Use of dangerous string functions that can cause buffer overflows"
                .to_string(),
            cve_references: vec!["CVE-2021-44228".to_string(), "CVE-2020-1472".to_string()],
            cwe_references: vec!["CWE-120".to_string(), "CWE-121".to_string()],
            mitigation:
                "Replace with safe alternatives: strcpy->strncpy, strcat->strncat, gets->fgets"
                    .to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec![
                    "strcpy".to_string(),
                    "strcat".to_string(),
                    "gets".to_string(),
                    "sprintf".to_string(),
                    "vsprintf".to_string(),
                ],
                context_checks: vec![ContextCheck::HasBoundsCheck],
            },
        });

        self.add_rule(VulnerabilityRule {
            id: "BOF002".to_string(),
            name: "Stack Buffer Allocation".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::BufferOverflow,
            description: "Large stack buffer allocation without bounds checking".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-121".to_string()],
            mitigation: "Use heap allocation or implement proper bounds checking".to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![
                    InstructionMatcher::Mnemonic("sub".to_string()),
                    InstructionMatcher::Register("rsp".to_string()),
                ],
                window_size: 2,
            },
        });

        // Format String Vulnerabilities
        self.add_rule(VulnerabilityRule {
            id: "FMT001".to_string(),
            name: "Format String Vulnerability".to_string(),
            severity: Severity::Critical,
            category: VulnerabilityCategory::FormatString,
            description: "User-controlled format string in printf family functions".to_string(),
            cve_references: vec!["CVE-2000-0573".to_string()],
            cwe_references: vec!["CWE-134".to_string()],
            mitigation: "Always use format specifiers like printf(\"%s\", user_input)".to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec![
                    "printf".to_string(),
                    "fprintf".to_string(),
                    "sprintf".to_string(),
                    "snprintf".to_string(),
                    "vprintf".to_string(),
                    "vfprintf".to_string(),
                    "vsprintf".to_string(),
                    "vsnprintf".to_string(),
                ],
                context_checks: vec![ContextCheck::UserInputSource],
            },
        });

        // Integer Overflow
        self.add_rule(VulnerabilityRule {
            id: "INT001".to_string(),
            name: "Integer Overflow in Arithmetic".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::IntegerOverflow,
            description: "Arithmetic operations that may cause integer overflow".to_string(),
            cve_references: vec!["CVE-2021-3156".to_string()],
            cwe_references: vec!["CWE-190".to_string()],
            mitigation: "Use safe arithmetic functions or check for overflow before operations"
                .to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![
                    InstructionMatcher::InstructionType(InstructionType::Arithmetic),
                    InstructionMatcher::InstructionType(InstructionType::Memory),
                ],
                window_size: 3,
            },
        });

        // Use After Free
        self.add_rule(VulnerabilityRule {
            id: "UAF001".to_string(),
            name: "Potential Use After Free".to_string(),
            severity: Severity::Critical,
            category: VulnerabilityCategory::UseAfterFree,
            description: "Memory access after free operation".to_string(),
            cve_references: vec!["CVE-2021-22555".to_string()],
            cwe_references: vec!["CWE-416".to_string()],
            mitigation: "Set pointers to NULL after free and check before use".to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec!["free".to_string(), "delete".to_string()],
                context_checks: vec![ContextCheck::HasNullCheck],
            },
        });

        // Double Free
        self.add_rule(VulnerabilityRule {
            id: "DBF001".to_string(),
            name: "Double Free Vulnerability".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::DoubleFree,
            description: "Multiple free operations on the same memory".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-415".to_string()],
            mitigation: "Set pointers to NULL after free and check before subsequent free"
                .to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec!["free".to_string(), "delete".to_string()],
                context_checks: vec![],
            },
        });

        // Null Pointer Dereference
        self.add_rule(VulnerabilityRule {
            id: "NPD001".to_string(),
            name: "Null Pointer Dereference".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::NullPointerDereference,
            description: "Potential null pointer dereference".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-476".to_string()],
            mitigation: "Always check pointers for NULL before dereferencing".to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![
                    InstructionMatcher::InstructionType(InstructionType::Memory),
                    InstructionMatcher::Immediate(0),
                ],
                window_size: 2,
            },
        });

        // Division by Zero
        self.add_rule(VulnerabilityRule {
            id: "DIV001".to_string(),
            name: "Division by Zero".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::DivisionByZero,
            description: "Division operation without zero check".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-369".to_string()],
            mitigation: "Check divisor for zero before division operations".to_string(),
            pattern: DetectionPattern::InstructionSequence {
                pattern: vec![InstructionMatcher::Mnemonic("div".to_string())],
                window_size: 1,
            },
        });

        // Uncontrolled Recursion
        self.add_rule(VulnerabilityRule {
            id: "REC001".to_string(),
            name: "Uncontrolled Recursion".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::UncontrolledRecursion,
            description: "Function with high cyclomatic complexity indicating potential uncontrolled recursion".to_string(),
            cve_references: vec![],
            cwe_references: vec!["CWE-674".to_string()],
            mitigation: "Implement recursion depth limits and iterative alternatives".to_string(),
            pattern: DetectionPattern::ControlFlowPattern {
                pattern_type: ControlFlowPatternType::DeepRecursion,
                complexity_threshold: Some(10),
            },
        });

        // Populate dangerous functions set
        for rule in &self.rules {
            if let DetectionPattern::UnsafeFunction { function_names, .. } = &rule.pattern {
                for func_name in function_names {
                    self.dangerous_functions.insert(func_name.clone());
                }
            }
        }
    }

    fn add_rule(&mut self, rule: VulnerabilityRule) {
        self.rules.push(rule);
    }

    pub fn analyze(
        &self,
        symbol_table: &SymbolTable,
        cfg_analysis: &ControlFlowAnalysis,
    ) -> Result<VulnerabilityDetectionResult> {
        let start_time = std::time::Instant::now();
        let mut vulnerabilities = Vec::new();
        let mut patterns_matched = 0;

        // Analyze each function's CFG for vulnerabilities
        for cfg in &cfg_analysis.cfgs {
            let function_vulns = self.analyze_function(cfg, symbol_table)?;
            patterns_matched += function_vulns.len();
            vulnerabilities.extend(function_vulns);
        }

        // Analyze symbol table for dangerous imports
        let import_vulns = self.analyze_imports(symbol_table)?;
        vulnerabilities.extend(import_vulns);

        // Calculate risk assessment
        let risk_assessment = self.calculate_risk_assessment(&vulnerabilities);

        let duration = start_time.elapsed().as_millis() as u64;

        Ok(VulnerabilityDetectionResult {
            vulnerabilities,
            risk_assessment,
            detection_stats: DetectionStats {
                analysis_duration_ms: duration,
                functions_analyzed: cfg_analysis.cfgs.len(),
                instructions_analyzed: cfg_analysis.analysis_stats.instructions_analyzed,
                rules_executed: self.rules.len(),
                patterns_matched,
            },
        })
    }

    fn analyze_function(
        &self,
        cfg: &ControlFlowGraph,
        _symbol_table: &SymbolTable,
    ) -> Result<Vec<DetectedVulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Check each rule against this function
        for rule in &self.rules {
            match &rule.pattern {
                DetectionPattern::UnsafeFunction {
                    function_names,
                    context_checks,
                } => {
                    if let Some(vuln) =
                        self.check_unsafe_function_calls(cfg, rule, function_names, context_checks)?
                    {
                        vulnerabilities.push(vuln);
                    }
                }
                DetectionPattern::InstructionSequence {
                    pattern,
                    window_size,
                } => {
                    if let Some(vuln) =
                        self.check_instruction_sequence(cfg, rule, pattern, *window_size)?
                    {
                        vulnerabilities.push(vuln);
                    }
                }
                DetectionPattern::ControlFlowPattern {
                    pattern_type,
                    complexity_threshold,
                } => {
                    if let Some(vuln) = self.check_control_flow_pattern(
                        cfg,
                        rule,
                        pattern_type,
                        *complexity_threshold,
                    )? {
                        vulnerabilities.push(vuln);
                    }
                }
                _ => {
                    // TODO: Implement other pattern types
                }
            }
        }

        Ok(vulnerabilities)
    }

    fn check_unsafe_function_calls(
        &self,
        cfg: &ControlFlowGraph,
        rule: &VulnerabilityRule,
        function_names: &[String],
        _context_checks: &[ContextCheck],
    ) -> Result<Option<DetectedVulnerability>> {
        let mut locations = Vec::new();

        // Check all instructions in all basic blocks
        for basic_block in &cfg.basic_blocks {
            for instruction in &basic_block.instructions {
                // Check if instruction is a call to a dangerous function
                if matches!(instruction.instruction_type, InstructionType::Call) {
                    if let FlowControl::Call(_) = instruction.flow_control {
                        // Parse the operand to extract function name
                        let operand = &instruction.operands;
                        for func_name in function_names {
                            if operand.contains(func_name) || instruction.mnemonic.contains("call")
                            {
                                locations.push(CodeLocation {
                                    function_name: cfg.function_name.clone(),
                                    function_address: cfg.function_address,
                                    instruction_address: instruction.address,
                                    basic_block_id: basic_block.id,
                                    instruction: format!(
                                        "{} {}",
                                        instruction.mnemonic, instruction.operands
                                    ),
                                    source_line: None,
                                });
                                break;
                            }
                        }
                    }
                }
            }
        }

        if !locations.is_empty() {
            Ok(Some(DetectedVulnerability {
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                severity: rule.severity.clone(),
                category: rule.category.clone(),
                description: rule.description.clone(),
                locations,
                confidence: 0.8, // High confidence for direct function calls
                context: format!(
                    "Function {} contains calls to dangerous functions",
                    cfg.function_name
                ),
                cve_references: rule.cve_references.clone(),
                cwe_references: rule.cwe_references.clone(),
                mitigation: rule.mitigation.clone(),
            }))
        } else {
            Ok(None)
        }
    }

    fn check_instruction_sequence(
        &self,
        cfg: &ControlFlowGraph,
        rule: &VulnerabilityRule,
        pattern: &[InstructionMatcher],
        window_size: usize,
    ) -> Result<Option<DetectedVulnerability>> {
        let mut locations = Vec::new();

        // Check instruction sequences in each basic block
        for basic_block in &cfg.basic_blocks {
            let instructions = &basic_block.instructions;

            for window_start in 0..instructions.len().saturating_sub(window_size - 1) {
                let window = &instructions
                    [window_start..std::cmp::min(window_start + window_size, instructions.len())];

                if self.matches_instruction_pattern(window, pattern) {
                    if let Some(first_instruction) = window.first() {
                        locations.push(CodeLocation {
                            function_name: cfg.function_name.clone(),
                            function_address: cfg.function_address,
                            instruction_address: first_instruction.address,
                            basic_block_id: basic_block.id,
                            instruction: format!(
                                "{} {}",
                                first_instruction.mnemonic, first_instruction.operands
                            ),
                            source_line: None,
                        });
                    }
                }
            }
        }

        if !locations.is_empty() {
            Ok(Some(DetectedVulnerability {
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                severity: rule.severity.clone(),
                category: rule.category.clone(),
                description: rule.description.clone(),
                locations,
                confidence: 0.6, // Medium confidence for instruction patterns
                context: format!(
                    "Function {} contains suspicious instruction patterns",
                    cfg.function_name
                ),
                cve_references: rule.cve_references.clone(),
                cwe_references: rule.cwe_references.clone(),
                mitigation: rule.mitigation.clone(),
            }))
        } else {
            Ok(None)
        }
    }

    fn check_control_flow_pattern(
        &self,
        cfg: &ControlFlowGraph,
        rule: &VulnerabilityRule,
        pattern_type: &ControlFlowPatternType,
        complexity_threshold: Option<u32>,
    ) -> Result<Option<DetectedVulnerability>> {
        let mut detected = false;
        let mut context = String::new();

        match pattern_type {
            ControlFlowPatternType::DeepRecursion => {
                if let Some(threshold) = complexity_threshold {
                    if cfg.complexity.cyclomatic_complexity > threshold {
                        detected = true;
                        context = format!(
                            "Function {} has high cyclomatic complexity ({}), indicating potential recursion issues",
                            cfg.function_name, cfg.complexity.cyclomatic_complexity
                        );
                    }
                }
            }
            ControlFlowPatternType::UncontrolledLoop => {
                if cfg.loops.len() > 3 {
                    detected = true;
                    context = format!(
                        "Function {} contains {} loops, potentially indicating uncontrolled iteration",
                        cfg.function_name, cfg.loops.len()
                    );
                }
            }
            ControlFlowPatternType::ComplexConditions => {
                if cfg.complexity.cognitive_complexity > 15 {
                    detected = true;
                    context = format!(
                        "Function {} has high cognitive complexity ({}), making it error-prone",
                        cfg.function_name, cfg.complexity.cognitive_complexity
                    );
                }
            }
            ControlFlowPatternType::UnreachableCode => {
                if !cfg.complexity.unreachable_blocks.is_empty() {
                    detected = true;
                    context = format!(
                        "Function {} contains {} unreachable basic blocks",
                        cfg.function_name,
                        cfg.complexity.unreachable_blocks.len()
                    );
                }
            }
            _ => {}
        }

        if detected {
            Ok(Some(DetectedVulnerability {
                rule_id: rule.id.clone(),
                rule_name: rule.name.clone(),
                severity: rule.severity.clone(),
                category: rule.category.clone(),
                description: rule.description.clone(),
                locations: vec![CodeLocation {
                    function_name: cfg.function_name.clone(),
                    function_address: cfg.function_address,
                    instruction_address: cfg.function_address,
                    basic_block_id: 0,
                    instruction: "Function-level analysis".to_string(),
                    source_line: None,
                }],
                confidence: 0.5, // Lower confidence for heuristic-based detection
                context,
                cve_references: rule.cve_references.clone(),
                cwe_references: rule.cwe_references.clone(),
                mitigation: rule.mitigation.clone(),
            }))
        } else {
            Ok(None)
        }
    }

    fn matches_instruction_pattern(
        &self,
        instructions: &[Instruction],
        pattern: &[InstructionMatcher],
    ) -> bool {
        if instructions.len() < pattern.len() {
            return false;
        }

        for (i, matcher) in pattern.iter().enumerate() {
            if i >= instructions.len() {
                return false;
            }

            let instruction = &instructions[i];
            match matcher {
                InstructionMatcher::Mnemonic(mnemonic) => {
                    if instruction.mnemonic != *mnemonic {
                        return false;
                    }
                }
                InstructionMatcher::InstructionType(inst_type) => {
                    if std::mem::discriminant(&instruction.instruction_type)
                        != std::mem::discriminant(inst_type)
                    {
                        return false;
                    }
                }
                InstructionMatcher::Register(reg) => {
                    if !instruction.operands.contains(reg) {
                        return false;
                    }
                }
                InstructionMatcher::AnyInstruction => {
                    // Always matches
                }
                _ => {
                    // TODO: Implement other matchers
                }
            }
        }

        true
    }

    fn analyze_imports(&self, symbol_table: &SymbolTable) -> Result<Vec<DetectedVulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Check for dangerous imported functions
        for import in &symbol_table.imports {
            if self.dangerous_functions.contains(&import.name) {
                // Find the corresponding rule
                if let Some(rule) = self.find_rule_for_function(&import.name) {
                    vulnerabilities.push(DetectedVulnerability {
                        rule_id: rule.id.clone(),
                        rule_name: rule.name.clone(),
                        severity: rule.severity.clone(),
                        category: rule.category.clone(),
                        description: format!("Import of dangerous function: {}", import.name),
                        locations: vec![CodeLocation {
                            function_name: "Imports".to_string(),
                            function_address: 0,
                            instruction_address: 0,
                            basic_block_id: 0,
                            instruction: format!("import {}", import.name),
                            source_line: None,
                        }],
                        confidence: 0.9,
                        context: format!("Binary imports dangerous function {}", import.name),
                        cve_references: rule.cve_references.clone(),
                        cwe_references: rule.cwe_references.clone(),
                        mitigation: rule.mitigation.clone(),
                    });
                }
            }
        }

        Ok(vulnerabilities)
    }

    fn find_rule_for_function(&self, function_name: &str) -> Option<&VulnerabilityRule> {
        self.rules.iter().find(|rule| {
            if let DetectionPattern::UnsafeFunction { function_names, .. } = &rule.pattern {
                function_names.contains(&function_name.to_string())
            } else {
                false
            }
        })
    }

    fn calculate_risk_assessment(
        &self,
        vulnerabilities: &[DetectedVulnerability],
    ) -> RiskAssessment {
        let mut critical_count = 0;
        let mut high_count = 0;
        let mut medium_count = 0;
        let mut low_count = 0;

        let mut total_score = 0.0;

        for vuln in vulnerabilities {
            let severity_score = match vuln.severity {
                Severity::Critical => {
                    critical_count += 1;
                    10.0
                }
                Severity::High => {
                    high_count += 1;
                    7.5
                }
                Severity::Medium => {
                    medium_count += 1;
                    5.0
                }
                Severity::Low => {
                    low_count += 1;
                    2.5
                }
                Severity::Info => 1.0,
            };

            total_score += severity_score * vuln.confidence;
        }

        let overall_risk_score = if vulnerabilities.is_empty() {
            0.0
        } else {
            (total_score / vulnerabilities.len() as f32).min(10.0)
        };

        let risk_level = match overall_risk_score {
            score if score >= 8.0 => RiskLevel::Critical,
            score if score >= 6.0 => RiskLevel::High,
            score if score >= 4.0 => RiskLevel::Medium,
            score if score >= 2.0 => RiskLevel::Low,
            _ => RiskLevel::Minimal,
        };

        let mut recommendations = Vec::new();
        if critical_count > 0 {
            recommendations
                .push("Immediate remediation required for critical vulnerabilities".to_string());
        }
        if high_count > 0 {
            recommendations
                .push("Address high severity vulnerabilities within 24 hours".to_string());
        }
        if medium_count > 0 {
            recommendations.push("Plan remediation for medium severity issues".to_string());
        }
        if vulnerabilities.is_empty() {
            recommendations.push("No vulnerabilities detected in static analysis".to_string());
        }

        RiskAssessment {
            overall_risk_score,
            critical_count,
            high_count,
            medium_count,
            low_count,
            total_vulnerabilities: vulnerabilities.len() as u32,
            risk_level,
            recommendations,
        }
    }
}

pub fn analyze_vulnerabilities(
    _path: &Path,
    symbol_table: &SymbolTable,
    cfg_analysis: &ControlFlowAnalysis,
) -> Result<VulnerabilityDetectionResult> {
    let detector = VulnerabilityDetector::new();
    detector.analyze(symbol_table, cfg_analysis)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::control_flow::{
        AnalysisStats, BasicBlock, BlockType, ControlFlowAnalysis, ControlFlowGraph,
        ControlFlowMetrics, FlowControl, Instruction, InstructionType, OverallMetrics,
    };
    use crate::function_analysis::{ExportInfo, ImportInfo, SymbolCounts, SymbolTable};

    fn create_mock_instruction(
        address: u64,
        mnemonic: &str,
        operands: &str,
        instruction_type: InstructionType,
        flow_control: FlowControl,
    ) -> Instruction {
        Instruction {
            address,
            bytes: vec![0x90, 0x90, 0x90, 0x90], // NOP bytes
            mnemonic: mnemonic.to_string(),
            operands: operands.to_string(),
            instruction_type,
            flow_control,
            size: 4,
        }
    }

    fn create_mock_basic_block(id: usize, instructions: Vec<Instruction>) -> BasicBlock {
        let instruction_count = instructions.len();
        BasicBlock {
            id,
            start_address: instructions.first().map(|i| i.address).unwrap_or(0),
            end_address: instructions.last().map(|i| i.address).unwrap_or(0) + 4,
            instructions,
            predecessors: Vec::new(),
            successors: Vec::new(),
            block_type: BlockType::Normal,
            instruction_count,
        }
    }

    fn create_mock_cfg(
        function_name: &str,
        function_address: u64,
        basic_blocks: Vec<BasicBlock>,
    ) -> ControlFlowGraph {
        let complexity = ControlFlowMetrics {
            cyclomatic_complexity: 5,
            cognitive_complexity: 8,
            nesting_depth: 3,
            basic_block_count: basic_blocks.len(),
            edge_count: 0,
            loop_count: 0,
            unreachable_blocks: Vec::new(),
        };

        ControlFlowGraph {
            function_name: function_name.to_string(),
            function_address,
            basic_blocks,
            edges: Vec::new(),
            entry_block: 0,
            exit_blocks: Vec::new(),
            loops: Vec::new(),
            complexity,
        }
    }

    fn create_mock_symbol_table(imports: Vec<ImportInfo>, exports: Vec<ExportInfo>) -> SymbolTable {
        let imported_functions = imports.len();
        let exported_functions = exports.len();
        SymbolTable {
            functions: Vec::new(),
            global_variables: Vec::new(),
            cross_references: Vec::new(),
            imports,
            exports,
            symbol_count: SymbolCounts {
                total_functions: 0,
                local_functions: 0,
                imported_functions,
                exported_functions,
                global_variables: 0,
                cross_references: 0,
            },
        }
    }

    fn create_mock_cfg_analysis(cfgs: Vec<ControlFlowGraph>) -> ControlFlowAnalysis {
        ControlFlowAnalysis {
            cfgs,
            overall_metrics: OverallMetrics {
                total_functions: 1,
                analyzed_functions: 1,
                total_basic_blocks: 2,
                average_complexity: 5.0,
                max_complexity: 10,
                function_with_max_complexity: Some("test_func".to_string()),
            },
            analysis_stats: AnalysisStats {
                analysis_duration: 100,
                bytes_analyzed: 1024,
                instructions_analyzed: 10,
                errors: Vec::new(),
            },
        }
    }

    #[test]
    fn test_vulnerability_detector_creation() {
        let detector = VulnerabilityDetector::new();

        // Should have loaded default rules
        assert!(!detector.rules.is_empty());
        assert!(!detector.dangerous_functions.is_empty());

        // Check that some expected dangerous functions are present
        assert!(detector.dangerous_functions.contains("strcpy"));
        assert!(detector.dangerous_functions.contains("gets"));
        assert!(detector.dangerous_functions.contains("printf"));
        assert!(detector.dangerous_functions.contains("free"));
    }

    #[test]
    fn test_detected_vulnerability_creation() {
        let vuln = DetectedVulnerability {
            rule_id: "TEST001".to_string(),
            rule_name: "Test Rule".to_string(),
            severity: Severity::High,
            category: VulnerabilityCategory::BufferOverflow,
            description: "Test vulnerability".to_string(),
            locations: vec![CodeLocation {
                function_name: "test_func".to_string(),
                function_address: 0x1000,
                instruction_address: 0x1004,
                basic_block_id: 0,
                instruction: "call strcpy".to_string(),
                source_line: Some(42),
            }],
            confidence: 0.8,
            context: "Test context".to_string(),
            cve_references: vec!["CVE-2021-1234".to_string()],
            cwe_references: vec!["CWE-120".to_string()],
            mitigation: "Use strncpy instead".to_string(),
        };

        assert_eq!(vuln.rule_id, "TEST001");
        assert_eq!(vuln.severity, Severity::High);
        assert_eq!(vuln.locations.len(), 1);
        assert_eq!(vuln.confidence, 0.8);
    }

    #[test]
    fn test_code_location_properties() {
        let location = CodeLocation {
            function_name: "vulnerable_func".to_string(),
            function_address: 0x2000,
            instruction_address: 0x2010,
            basic_block_id: 1,
            instruction: "mov eax, [ebx]".to_string(),
            source_line: None,
        };

        assert_eq!(location.function_name, "vulnerable_func");
        assert_eq!(location.function_address, 0x2000);
        assert_eq!(location.instruction_address, 0x2010);
        assert_eq!(location.basic_block_id, 1);
        assert!(location.source_line.is_none());
    }

    #[test]
    fn test_severity_levels() {
        let severities = vec![
            Severity::Critical,
            Severity::High,
            Severity::Medium,
            Severity::Low,
            Severity::Info,
        ];

        assert_eq!(severities.len(), 5);

        // Test serialization
        for severity in severities {
            let json = serde_json::to_string(&severity).unwrap();
            let deserialized: Severity = serde_json::from_str(&json).unwrap();
            assert_eq!(
                std::mem::discriminant(&severity),
                std::mem::discriminant(&deserialized)
            );
        }
    }

    #[test]
    fn test_vulnerability_categories() {
        let categories = vec![
            VulnerabilityCategory::BufferOverflow,
            VulnerabilityCategory::FormatString,
            VulnerabilityCategory::IntegerOverflow,
            VulnerabilityCategory::UseAfterFree,
            VulnerabilityCategory::NullPointerDereference,
            VulnerabilityCategory::RaceCondition,
            VulnerabilityCategory::InjectionVulnerability,
            VulnerabilityCategory::CryptographicWeakness,
            VulnerabilityCategory::MemoryLeak,
            VulnerabilityCategory::DoubleFree,
            VulnerabilityCategory::UncontrolledRecursion,
            VulnerabilityCategory::DivisionByZero,
            VulnerabilityCategory::SignedIntegerOverflow,
            VulnerabilityCategory::UnsafeAPIUsage,
        ];

        assert_eq!(categories.len(), 14);

        // Test serialization for a few key categories
        let json = serde_json::to_string(&VulnerabilityCategory::BufferOverflow).unwrap();
        let deserialized: VulnerabilityCategory = serde_json::from_str(&json).unwrap();
        assert!(matches!(
            deserialized,
            VulnerabilityCategory::BufferOverflow
        ));
    }

    #[test]
    fn test_risk_levels() {
        let levels = vec![
            RiskLevel::Critical,
            RiskLevel::High,
            RiskLevel::Medium,
            RiskLevel::Low,
            RiskLevel::Minimal,
        ];

        assert_eq!(levels.len(), 5);

        // Test serialization
        for level in levels {
            let json = serde_json::to_string(&level).unwrap();
            let deserialized: RiskLevel = serde_json::from_str(&json).unwrap();
            assert_eq!(
                std::mem::discriminant(&level),
                std::mem::discriminant(&deserialized)
            );
        }
    }

    #[test]
    fn test_detection_pattern_unsafe_function() {
        let pattern = DetectionPattern::UnsafeFunction {
            function_names: vec!["strcpy".to_string(), "gets".to_string()],
            context_checks: vec![ContextCheck::HasBoundsCheck, ContextCheck::HasNullCheck],
        };

        match pattern {
            DetectionPattern::UnsafeFunction {
                function_names,
                context_checks,
            } => {
                assert_eq!(function_names.len(), 2);
                assert_eq!(context_checks.len(), 2);
                assert!(function_names.contains(&"strcpy".to_string()));
                assert!(function_names.contains(&"gets".to_string()));
            }
            _ => panic!("Expected UnsafeFunction pattern"),
        }
    }

    #[test]
    fn test_detection_pattern_instruction_sequence() {
        let pattern = DetectionPattern::InstructionSequence {
            pattern: vec![
                InstructionMatcher::Mnemonic("mov".to_string()),
                InstructionMatcher::InstructionType(InstructionType::Memory),
            ],
            window_size: 2,
        };

        match pattern {
            DetectionPattern::InstructionSequence {
                pattern,
                window_size,
            } => {
                assert_eq!(pattern.len(), 2);
                assert_eq!(window_size, 2);
            }
            _ => panic!("Expected InstructionSequence pattern"),
        }
    }

    #[test]
    fn test_instruction_matchers() {
        let matchers = vec![
            InstructionMatcher::Mnemonic("call".to_string()),
            InstructionMatcher::InstructionType(InstructionType::Call),
            InstructionMatcher::FlowControl(FlowControl::Call(0x1000)),
            InstructionMatcher::Register("eax".to_string()),
            InstructionMatcher::Immediate(0x100),
            InstructionMatcher::AnyInstruction,
        ];

        assert_eq!(matchers.len(), 6);

        // Test that each matcher type can be created
        for matcher in matchers {
            match matcher {
                InstructionMatcher::Mnemonic(_)
                | InstructionMatcher::InstructionType(_)
                | InstructionMatcher::FlowControl(_)
                | InstructionMatcher::Register(_)
                | InstructionMatcher::Immediate(_)
                | InstructionMatcher::AnyInstruction => {}
            }
        }
    }

    #[test]
    fn test_analyze_empty_cfg() {
        let detector = VulnerabilityDetector::new();
        let symbol_table = create_mock_symbol_table(vec![], vec![]);
        let cfg_analysis = create_mock_cfg_analysis(vec![]);

        let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

        assert_eq!(result.vulnerabilities.len(), 0);
        assert_eq!(result.risk_assessment.total_vulnerabilities, 0);
        assert_eq!(result.risk_assessment.overall_risk_score, 0.0);
        assert!(matches!(
            result.risk_assessment.risk_level,
            RiskLevel::Minimal
        ));
        assert_eq!(result.detection_stats.functions_analyzed, 0);
    }

    #[test]
    fn test_analyze_function_with_dangerous_calls() {
        let detector = VulnerabilityDetector::new();

        // Create instructions with dangerous function calls
        let instructions = vec![
            create_mock_instruction(
                0x1000,
                "call",
                "strcpy@PLT", // Make operand contain function name
                InstructionType::Call,
                FlowControl::Call(0x2000),
            ),
            create_mock_instruction(
                0x1004,
                "call",
                "gets@PLT", // Make operand contain function name
                InstructionType::Call,
                FlowControl::Call(0x2004),
            ),
        ];

        let basic_block = create_mock_basic_block(0, instructions);
        let cfg = create_mock_cfg("vulnerable_func", 0x1000, vec![basic_block]);

        let vulnerabilities = detector
            .analyze_function(&cfg, &create_mock_symbol_table(vec![], vec![]))
            .unwrap();

        // Should detect vulnerabilities for dangerous function calls
        assert!(!vulnerabilities.is_empty());

        for vuln in &vulnerabilities {
            // Check that we detect reasonable vulnerability categories
            // All of these categories can be triggered by call instructions
            assert!(matches!(
                vuln.category,
                VulnerabilityCategory::BufferOverflow
                    | VulnerabilityCategory::FormatString
                    | VulnerabilityCategory::UseAfterFree
                    | VulnerabilityCategory::DoubleFree
            ));
            assert!(!vuln.locations.is_empty());
            assert!(vuln.confidence > 0.5);
        }
    }

    #[test]
    fn test_analyze_function_with_instruction_patterns() {
        let detector = VulnerabilityDetector::new();

        // Create instructions that match division pattern
        let instructions = vec![create_mock_instruction(
            0x1000,
            "div",
            "eax",
            InstructionType::Arithmetic,
            FlowControl::Fall,
        )];

        let basic_block = create_mock_basic_block(0, instructions);
        let cfg = create_mock_cfg("test_func", 0x1000, vec![basic_block]);

        let vulnerabilities = detector
            .analyze_function(&cfg, &create_mock_symbol_table(vec![], vec![]))
            .unwrap();

        // Should detect division by zero vulnerability
        let div_vulns: Vec<_> = vulnerabilities
            .iter()
            .filter(|v| matches!(v.category, VulnerabilityCategory::DivisionByZero))
            .collect();
        assert!(!div_vulns.is_empty());
    }

    #[test]
    fn test_analyze_function_with_high_complexity() {
        let detector = VulnerabilityDetector::new();

        let basic_block = create_mock_basic_block(0, vec![]);
        let mut cfg = create_mock_cfg("complex_func", 0x1000, vec![basic_block]);

        // Set high complexity to trigger recursion detection
        cfg.complexity.cyclomatic_complexity = 15;
        cfg.complexity.cognitive_complexity = 20;

        let vulnerabilities = detector
            .analyze_function(&cfg, &create_mock_symbol_table(vec![], vec![]))
            .unwrap();

        // Should detect high complexity issues
        let complexity_vulns: Vec<_> = vulnerabilities
            .iter()
            .filter(|v| matches!(v.category, VulnerabilityCategory::UncontrolledRecursion))
            .collect();
        assert!(!complexity_vulns.is_empty());
    }

    #[test]
    fn test_analyze_imports_with_dangerous_functions() {
        let detector = VulnerabilityDetector::new();

        let imports = vec![
            ImportInfo {
                name: "strcpy".to_string(),
                address: Some(0x2000),
                library: Some("libc".to_string()),
                ordinal: None,
                is_delayed: false,
            },
            ImportInfo {
                name: "safe_function".to_string(),
                address: Some(0x2004),
                library: Some("libsafe".to_string()),
                ordinal: None,
                is_delayed: false,
            },
            ImportInfo {
                name: "printf".to_string(),
                address: Some(0x2008),
                library: Some("libc".to_string()),
                ordinal: None,
                is_delayed: false,
            },
        ];

        let symbol_table = create_mock_symbol_table(imports, vec![]);
        let vulnerabilities = detector.analyze_imports(&symbol_table).unwrap();

        // Should detect vulnerabilities for dangerous imports
        assert_eq!(vulnerabilities.len(), 2); // strcpy and printf

        for vuln in &vulnerabilities {
            assert!(vuln.locations[0].function_name == "Imports");
            assert!(vuln.confidence > 0.8);
            assert!(vuln.locations[0].instruction.contains("import"));
        }
    }

    #[test]
    fn test_matches_instruction_pattern() {
        let detector = VulnerabilityDetector::new();

        let instructions = vec![
            create_mock_instruction(
                0x1000,
                "mov",
                "eax, ebx",
                InstructionType::Memory,
                FlowControl::Fall,
            ),
            create_mock_instruction(
                0x1004,
                "add",
                "eax, 1",
                InstructionType::Arithmetic,
                FlowControl::Fall,
            ),
        ];

        // Test exact mnemonic match
        let pattern1 = vec![InstructionMatcher::Mnemonic("mov".to_string())];
        assert!(detector.matches_instruction_pattern(&instructions, &pattern1));

        // Test instruction type match
        let pattern2 = vec![InstructionMatcher::InstructionType(InstructionType::Memory)];
        assert!(detector.matches_instruction_pattern(&instructions, &pattern2));

        // Test register match
        let pattern3 = vec![InstructionMatcher::Register("eax".to_string())];
        assert!(detector.matches_instruction_pattern(&instructions, &pattern3));

        // Test any instruction match
        let pattern4 = vec![InstructionMatcher::AnyInstruction];
        assert!(detector.matches_instruction_pattern(&instructions, &pattern4));

        // Test sequence match
        let pattern5 = vec![
            InstructionMatcher::Mnemonic("mov".to_string()),
            InstructionMatcher::Mnemonic("add".to_string()),
        ];
        assert!(detector.matches_instruction_pattern(&instructions, &pattern5));

        // Test no match
        let pattern6 = vec![InstructionMatcher::Mnemonic("call".to_string())];
        assert!(!detector.matches_instruction_pattern(&instructions, &pattern6));
    }

    #[test]
    fn test_find_rule_for_function() {
        let detector = VulnerabilityDetector::new();

        // Should find rule for strcpy
        let rule = detector.find_rule_for_function("strcpy");
        assert!(rule.is_some());
        assert_eq!(rule.unwrap().id, "BOF001");

        // Should find rule for printf
        let rule = detector.find_rule_for_function("printf");
        assert!(rule.is_some());
        assert_eq!(rule.unwrap().id, "FMT001");

        // Should not find rule for safe function
        let rule = detector.find_rule_for_function("safe_function");
        assert!(rule.is_none());
    }

    #[test]
    fn test_calculate_risk_assessment_empty() {
        let detector = VulnerabilityDetector::new();
        let vulnerabilities = vec![];

        let risk = detector.calculate_risk_assessment(&vulnerabilities);

        assert_eq!(risk.overall_risk_score, 0.0);
        assert_eq!(risk.critical_count, 0);
        assert_eq!(risk.high_count, 0);
        assert_eq!(risk.medium_count, 0);
        assert_eq!(risk.low_count, 0);
        assert_eq!(risk.total_vulnerabilities, 0);
        assert!(matches!(risk.risk_level, RiskLevel::Minimal));
        assert!(!risk.recommendations.is_empty());
    }

    #[test]
    fn test_calculate_risk_assessment_with_vulnerabilities() {
        let detector = VulnerabilityDetector::new();

        let vulnerabilities = vec![
            DetectedVulnerability {
                rule_id: "CRIT001".to_string(),
                rule_name: "Critical Issue".to_string(),
                severity: Severity::Critical,
                category: VulnerabilityCategory::BufferOverflow,
                description: "Critical vulnerability".to_string(),
                locations: vec![],
                confidence: 1.0,
                context: "Critical context".to_string(),
                cve_references: vec![],
                cwe_references: vec![],
                mitigation: "Fix immediately".to_string(),
            },
            DetectedVulnerability {
                rule_id: "HIGH001".to_string(),
                rule_name: "High Issue".to_string(),
                severity: Severity::High,
                category: VulnerabilityCategory::FormatString,
                description: "High severity vulnerability".to_string(),
                locations: vec![],
                confidence: 0.8,
                context: "High context".to_string(),
                cve_references: vec![],
                cwe_references: vec![],
                mitigation: "Fix soon".to_string(),
            },
            DetectedVulnerability {
                rule_id: "MED001".to_string(),
                rule_name: "Medium Issue".to_string(),
                severity: Severity::Medium,
                category: VulnerabilityCategory::NullPointerDereference,
                description: "Medium severity vulnerability".to_string(),
                locations: vec![],
                confidence: 0.6,
                context: "Medium context".to_string(),
                cve_references: vec![],
                cwe_references: vec![],
                mitigation: "Plan fix".to_string(),
            },
        ];

        let risk = detector.calculate_risk_assessment(&vulnerabilities);

        assert_eq!(risk.critical_count, 1);
        assert_eq!(risk.high_count, 1);
        assert_eq!(risk.medium_count, 1);
        assert_eq!(risk.low_count, 0);
        assert_eq!(risk.total_vulnerabilities, 3);
        assert!(risk.overall_risk_score > 6.0); // Should be high due to critical + high severity
        assert!(matches!(
            risk.risk_level,
            RiskLevel::High | RiskLevel::Critical
        ));
        assert!(risk.recommendations.len() >= 3); // Should have recommendations for critical, high, medium
    }

    #[test]
    fn test_vulnerability_detection_result_serialization() {
        let result = VulnerabilityDetectionResult {
            vulnerabilities: vec![DetectedVulnerability {
                rule_id: "TEST001".to_string(),
                rule_name: "Test Rule".to_string(),
                severity: Severity::High,
                category: VulnerabilityCategory::BufferOverflow,
                description: "Test vulnerability".to_string(),
                locations: vec![],
                confidence: 0.8,
                context: "Test context".to_string(),
                cve_references: vec!["CVE-2021-1234".to_string()],
                cwe_references: vec!["CWE-120".to_string()],
                mitigation: "Use safe functions".to_string(),
            }],
            risk_assessment: RiskAssessment {
                overall_risk_score: 7.5,
                critical_count: 0,
                high_count: 1,
                medium_count: 0,
                low_count: 0,
                total_vulnerabilities: 1,
                risk_level: RiskLevel::High,
                recommendations: vec!["Address high severity issues".to_string()],
            },
            detection_stats: DetectionStats {
                analysis_duration_ms: 100,
                functions_analyzed: 1,
                instructions_analyzed: 10,
                rules_executed: 8,
                patterns_matched: 1,
            },
        };

        // Test JSON serialization
        let json = serde_json::to_string(&result).unwrap();
        let deserialized: VulnerabilityDetectionResult = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.vulnerabilities.len(), 1);
        assert_eq!(deserialized.risk_assessment.total_vulnerabilities, 1);
        assert_eq!(deserialized.detection_stats.functions_analyzed, 1);
    }

    #[test]
    fn test_risk_assessment_serialization() {
        let risk = RiskAssessment {
            overall_risk_score: 5.5,
            critical_count: 1,
            high_count: 2,
            medium_count: 3,
            low_count: 4,
            total_vulnerabilities: 10,
            risk_level: RiskLevel::Medium,
            recommendations: vec![
                "Fix critical issues".to_string(),
                "Address high priority items".to_string(),
            ],
        };

        // Test JSON serialization
        let json = serde_json::to_string(&risk).unwrap();
        let deserialized: RiskAssessment = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.overall_risk_score, 5.5);
        assert_eq!(deserialized.critical_count, 1);
        assert_eq!(deserialized.total_vulnerabilities, 10);
        assert!(matches!(deserialized.risk_level, RiskLevel::Medium));
        assert_eq!(deserialized.recommendations.len(), 2);
    }

    #[test]
    fn test_detection_stats_properties() {
        let stats = DetectionStats {
            analysis_duration_ms: 250,
            functions_analyzed: 5,
            instructions_analyzed: 150,
            rules_executed: 12,
            patterns_matched: 3,
        };

        assert_eq!(stats.analysis_duration_ms, 250);
        assert_eq!(stats.functions_analyzed, 5);
        assert_eq!(stats.instructions_analyzed, 150);
        assert_eq!(stats.rules_executed, 12);
        assert_eq!(stats.patterns_matched, 3);

        // Test serialization
        let json = serde_json::to_string(&stats).unwrap();
        let deserialized: DetectionStats = serde_json::from_str(&json).unwrap();

        assert_eq!(
            deserialized.analysis_duration_ms,
            stats.analysis_duration_ms
        );
        assert_eq!(deserialized.functions_analyzed, stats.functions_analyzed);
        assert_eq!(
            deserialized.instructions_analyzed,
            stats.instructions_analyzed
        );
        assert_eq!(deserialized.rules_executed, stats.rules_executed);
        assert_eq!(deserialized.patterns_matched, stats.patterns_matched);
    }

    #[test]
    fn test_full_analysis_integration() {
        let detector = VulnerabilityDetector::new();

        // Create a complete test scenario with dangerous imports and function calls
        let imports = vec![ImportInfo {
            name: "strcpy".to_string(),
            address: Some(0x2000),
            library: Some("libc".to_string()),
            ordinal: None,
            is_delayed: false,
        }];

        let instructions = vec![
            create_mock_instruction(
                0x1000,
                "call",
                "strcpy@PLT", // Make operand contain function name
                InstructionType::Call,
                FlowControl::Call(0x2000),
            ),
            create_mock_instruction(
                0x1004,
                "div",
                "eax",
                InstructionType::Arithmetic,
                FlowControl::Fall,
            ),
        ];

        let basic_block = create_mock_basic_block(0, instructions);
        let cfg = create_mock_cfg("vulnerable_func", 0x1000, vec![basic_block]);
        let cfg_analysis = create_mock_cfg_analysis(vec![cfg]);
        let symbol_table = create_mock_symbol_table(imports, vec![]);

        let result = detector.analyze(&symbol_table, &cfg_analysis).unwrap();

        // Should detect multiple vulnerabilities
        assert!(!result.vulnerabilities.is_empty());
        assert!(result.risk_assessment.total_vulnerabilities > 0);
        assert!(result.risk_assessment.overall_risk_score > 0.0);
        // Duration should be recorded (but can be 0 for fast operations)
        let _duration = result.detection_stats.analysis_duration_ms;
        assert_eq!(result.detection_stats.functions_analyzed, 1);
        assert!(!result.risk_assessment.recommendations.is_empty());
    }

    #[test]
    fn test_analyze_vulnerabilities_function() {
        use std::path::Path;

        let path = Path::new("/test/file");
        let symbol_table = create_mock_symbol_table(vec![], vec![]);
        let cfg_analysis = create_mock_cfg_analysis(vec![]);

        let result = analyze_vulnerabilities(path, &symbol_table, &cfg_analysis);
        assert!(result.is_ok());

        let result = result.unwrap();
        assert_eq!(result.vulnerabilities.len(), 0);
        assert!(matches!(
            result.risk_assessment.risk_level,
            RiskLevel::Minimal
        ));
    }

    #[test]
    fn test_control_flow_pattern_types() {
        let patterns = vec![
            ControlFlowPatternType::DeepRecursion,
            ControlFlowPatternType::UncontrolledLoop,
            ControlFlowPatternType::ComplexConditions,
            ControlFlowPatternType::UnreachableCode,
            ControlFlowPatternType::MissingErrorHandling,
        ];

        assert_eq!(patterns.len(), 5);

        // Test that each pattern type can be used in pattern matching
        for pattern in patterns {
            match pattern {
                ControlFlowPatternType::DeepRecursion => {}
                ControlFlowPatternType::UncontrolledLoop => {}
                ControlFlowPatternType::ComplexConditions => {}
                ControlFlowPatternType::UnreachableCode => {}
                ControlFlowPatternType::MissingErrorHandling => {}
            }
        }
    }

    #[test]
    fn test_context_checks() {
        let checks = vec![
            ContextCheck::HasBoundsCheck,
            ContextCheck::HasNullCheck,
            ContextCheck::HasLengthValidation,
            ContextCheck::InLoopContext,
            ContextCheck::UserInputSource,
            ContextCheck::StackAllocation,
        ];

        assert_eq!(checks.len(), 6);

        // Test that each context check can be used
        for check in checks {
            match check {
                ContextCheck::HasBoundsCheck => {}
                ContextCheck::HasNullCheck => {}
                ContextCheck::HasLengthValidation => {}
                ContextCheck::InLoopContext => {}
                ContextCheck::UserInputSource => {}
                ContextCheck::StackAllocation => {}
            }
        }
    }

    #[test]
    fn test_memory_operations() {
        let operations = vec![
            MemoryOperation::Allocation,
            MemoryOperation::Deallocation,
            MemoryOperation::Access,
            MemoryOperation::Copy,
            MemoryOperation::Move,
        ];

        assert_eq!(operations.len(), 5);

        // Test that each operation can be used
        for operation in operations {
            match operation {
                MemoryOperation::Allocation => {}
                MemoryOperation::Deallocation => {}
                MemoryOperation::Access => {}
                MemoryOperation::Copy => {}
                MemoryOperation::Move => {}
            }
        }
    }

    #[test]
    fn test_combination_logic() {
        let logic_types = vec![
            CombinationLogic::And,
            CombinationLogic::Or,
            CombinationLogic::Not,
            CombinationLogic::Sequence,
        ];

        assert_eq!(logic_types.len(), 4);

        // Test that each logic type can be used
        for logic in logic_types {
            match logic {
                CombinationLogic::And => {}
                CombinationLogic::Or => {}
                CombinationLogic::Not => {}
                CombinationLogic::Sequence => {}
            }
        }
    }

    #[test]
    fn test_edge_cases() {
        let detector = VulnerabilityDetector::new();

        // Test empty instruction sequence matching
        let empty_instructions = vec![];
        let pattern = vec![InstructionMatcher::AnyInstruction];
        assert!(!detector.matches_instruction_pattern(&empty_instructions, &pattern));

        // Test pattern longer than instructions
        let short_instructions = vec![create_mock_instruction(
            0x1000,
            "mov",
            "eax, ebx",
            InstructionType::Memory,
            FlowControl::Fall,
        )];
        let long_pattern = vec![
            InstructionMatcher::Mnemonic("mov".to_string()),
            InstructionMatcher::Mnemonic("add".to_string()),
        ];
        assert!(!detector.matches_instruction_pattern(&short_instructions, &long_pattern));

        // Test finding rule for empty function name
        let rule = detector.find_rule_for_function("");
        assert!(rule.is_none());
    }

    #[test]
    fn test_vulnerability_rule_creation() {
        let rule = VulnerabilityRule {
            id: "CUSTOM001".to_string(),
            name: "Custom Rule".to_string(),
            severity: Severity::Medium,
            category: VulnerabilityCategory::MemoryLeak,
            description: "Custom vulnerability rule for testing".to_string(),
            cve_references: vec!["CVE-2022-1234".to_string()],
            cwe_references: vec!["CWE-401".to_string()],
            mitigation: "Properly manage memory".to_string(),
            pattern: DetectionPattern::UnsafeFunction {
                function_names: vec!["malloc".to_string()],
                context_checks: vec![ContextCheck::HasNullCheck],
            },
        };

        assert_eq!(rule.id, "CUSTOM001");
        assert_eq!(rule.name, "Custom Rule");
        assert!(matches!(rule.severity, Severity::Medium));
        assert!(matches!(rule.category, VulnerabilityCategory::MemoryLeak));
        assert_eq!(rule.cve_references.len(), 1);
        assert_eq!(rule.cwe_references.len(), 1);

        match rule.pattern {
            DetectionPattern::UnsafeFunction {
                function_names,
                context_checks,
            } => {
                assert_eq!(function_names.len(), 1);
                assert_eq!(context_checks.len(), 1);
                assert!(function_names.contains(&"malloc".to_string()));
            }
            _ => panic!("Expected UnsafeFunction pattern"),
        }
    }
}
